\section{Propuestas Analizadas}

% =========================
% Propuesta 1: HelenOS
% =========================
\subsection{HelenOS}

\subsubsection{Nombre del proyecto o sistema operativo}
HelenOS es un sistema operativo multiserver basado en un microkernel, desarrollado completamente desde cero y sin dependencia de Unix. Su diseño busca la modularidad, la portabilidad y la tolerancia a fallos, orientado principalmente a la investigación académica y la enseñanza de arquitectura de sistemas operativos \cite{helenos_about}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio oficial: \url{https://github.com/HelenOS/helenos}.

Sitio web del proyecto: \url{https://www.helenos.org}.

Documentación técnica (PDF): \url{https://www.helenos.org/doc/prjdoc.pdf}

\subsubsection{Objetivo del proyecto}
El objetivo de HelenOS es principalmente educativo y experimental. Su propósito es servir como plataforma de estudio de sistemas operativos modernos, promoviendo un enfoque modular donde cada servicio (sistema de archivos, red, controladores o interfaz gráfica) se implementa como un servidor independiente en espacio de usuario. Este diseño fomenta el análisis de conceptos avanzados como la comunicación entre procesos (IPC) y la separación entre el núcleo y los servicios de usuario \cite{helenos_about, helenos_prjdoc}.

\subsubsection{Lenguajes de implementación}
El proyecto está desarrollado principalmente en el lenguaje C, con partes críticas escritas en ensamblador (para el arranque del sistema y la gestión de interrupciones). Se mantiene compatibilidad con los estándares C11 y C++14, lo que facilita la portabilidad y la integración de nuevos componentes \cite{helenos_prjdoc}.

\subsubsection{Arquitectura del sistema}
HelenOS adopta una arquitectura de microkernel multiserver. El microkernel proporciona únicamente los servicios esenciales —planificación, gestión de memoria, interrupciones e IPC— mientras que todos los demás servicios (como el sistema de archivos, la red o la interfaz gráfica) se ejecutan como procesos de usuario independientes que se comunican mediante paso de mensajes (\textit{message passing}) \cite{helenos_prjdoc}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Gestión de procesos e hilos:} soporte de multitarea con planificación por prioridades y aislamiento entre procesos. El modelo de ejecución permite múltiples hilos por proceso y comunicación sincronizada entre ellos mediante IPC.
    \item \textbf{Gestión de memoria:} sistema de memoria virtual con paginación y protección por espacio de direcciones. El kernel se encarga de la asignación básica y los servidores de usuario gestionan asignadores dinámicos (\textit{slab allocators}) y regiones compartidas.
    \item \textbf{Sistema de archivos (VFS):} arquitectura de VFS donde cada tipo de sistema de archivos (por ejemplo, FAT, EXT2) se implementa como un servidor separado en espacio de usuario, permitiendo montar y desmontar sistemas de archivos sin reiniciar el núcleo.
    \item \textbf{Dispositivos y controladores:} \textit{drivers} en espacio de usuario, lo que evita que errores en controladores afecten la estabilidad general del sistema. Hay soporte para dispositivos de almacenamiento, red, USB, vídeo, teclado y ratón.
    \item \textbf{Sistema de red:} pila TCP/IP modular con soporte para IPv4, interfaces Ethernet virtuales y utilidades de diagnóstico como \texttt{ping}, \texttt{netstat}, \texttt{inet list-addr} y \texttt{arp}.
    \item \textbf{Sistema gráfico:} entorno gráfico de ventanas (GUI) que corre completamente en espacio de usuario, con aplicaciones como \textit{Terminal}, \textit{Text Editor}, \textit{Navigator}, \textit{Calculator}, \textit{GFX Demo} y \textit{Tetris}.
    \item \textbf{Comunicación e IPC:} sistema de comunicación entre procesos mediante intercambio de mensajes orientado a puertos.
    \item \textbf{Seguridad y aislamiento:} cada componente ejecuta con privilegios mínimos, lo que mejora la tolerancia a fallos.
    \item \textbf{Portabilidad:} soporte para \texttt{ia32}, \texttt{amd64}, \texttt{arm32}, \texttt{mips32}, \texttt{ppc32}, \texttt{sparc64} e \texttt{ia64}.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Toolchain cruzado:} generado mediante \texttt{tools/toolchain.sh}, que compila \texttt{gcc}, \texttt{binutils} y \texttt{gdb} adaptados a HelenOS.
    \item \textbf{Meson y Ninja:} sistema de construcción y generador de compilaciones incrementales.
    \item \textbf{Dependencias:} paquetes como \texttt{build-essential}, \texttt{wget}, \texttt{texinfo}, \texttt{flex}, \texttt{bison}, \texttt{dialog}, \texttt{python3-yaml} y \texttt{genisoimage}.
    \item \textbf{Emulación y prueba:} ejecución en \textit{QEMU} o \textit{VirtualBox}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{figures/helenos_toolchain.png}
    \caption{Elaboración propia. Compilación cruzada del script \texttt{toolchain.sh} del proyecto HelenOS.}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de HelenOS es alto, ya que su comprensión requiere conocimientos de compilación cruzada, IPC y gestión de memoria. Sin embargo, su estructura modular y la documentación disponible lo convierten en una herramienta didáctica sólida \cite{helenos_docs, manek2018}.

\begin{table}[H]
    \centering
    \caption{Ficha técnica resumida de HelenOS.}
    \vspace{2mm}
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Microkernel multiserver modular                                     \\ \hline
        \textbf{Lenguajes}         & C (principal) y ensamblador                                         \\
        \textbf{Arquitecturas}     & ia32, amd64, arm32, mips32, ppc32, sparc64                          \\
        \textbf{Componentes clave} & Kernel mínimo, VFS, red, GUI, controladores en espacio de usuario   \\
        \textbf{Herramientas}      & GCC (toolchain cruzado), Meson, Ninja, QEMU/VirtualBox              \\
        \textbf{Uso educativo}     & Alto: análisis modular de componentes e IPC                         \\
        \hline
    \end{tabular}
    \vspace{1mm}\\
    \textit{Nota. Adaptado de ``About HelenOS'' \cite{helenos_about}.}
\end{table}

% =========================
% Propuesta 2: Visopsys
% =========================
\subsection{Visopsys}

\subsubsection{Nombre del proyecto o sistema operativo}
Visopsys (\textit{Visual Operating System}) es un sistema operativo alternativo, gratuito y desarrollado desde cero por Andy McLaughlin desde 1997. No está basado en Unix ni en Linux, sino que implementa su propio kernel, gestor de archivos y entorno gráfico \cite{visopsys_about}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio y descargas: \url{https://sourceforge.net/projects/visopsys/files/} \cite{visopsys_sourceforge}.

Sitio web del proyecto: \url{https://visopsys.org} \cite{visopsys_about}.

Presentación técnica: \url{https://es.scribd.com/presentation/619552414/SO-visopsys} \cite{visopsys_scribd}.

\subsubsection{Objetivo del proyecto}
Visopsys tiene un objetivo principalmente educativo y experimental. Proporciona una plataforma funcional para demostrar principios de diseño de sistemas operativos, gestión de procesos, memoria y sistemas de archivos \cite{visopsys_scribd}.

\subsubsection{Lenguajes de implementación}
Está implementado principalmente en C, con secciones críticas en ensamblador x86 \cite{visopsys_sourceforge}.

\subsubsection{Arquitectura del sistema}
Visopsys implementa una arquitectura monolítica modular: el núcleo controla procesos, memoria, sistema de archivos y controladores, pero permite carga dinámica de módulos \cite{visopsys_about}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Gestión de procesos e hilos:} multitarea cooperativa y por prioridades.
    \item \textbf{Gestión de memoria:} memoria virtual simple con asignación dinámica y aislamiento básico.
    \item \textbf{Sistema de archivos:} soporte para FAT12, FAT16 y FAT32, con detección de particiones MBR y GPT.
    \item \textbf{Dispositivos y controladores:} controladores para discos IDE/SATA, vídeo en modo VESA, teclado, ratón y USB.
    \item \textbf{Interfaz gráfica:} entorno con ventanas, menús y barra de herramientas, con administrador de archivos, editor de texto y visor hexadecimal.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Compilador:} GCC y utilidades GNU (\texttt{make}, \texttt{binutils}).
    \item \textbf{Entorno de prueba:} \textit{VirtualBox} y \textit{QEMU}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/visopsys_gui.png}
    \caption{Entorno de escritorio de Visopsys ejecutado en máquina virtual. Extraído del sitio oficial del proyecto.}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de Visopsys es medio. Su estructura modular permite estudiar planificación, memoria, controladores y GUI en un único entorno funcional \cite{visopsys_scribd}.

\begin{table}[H]
    \centering
    \caption{Ficha técnica resumida de Visopsys.}
    \vspace{2mm}
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico modular con GUI integrada                         \\ \hline
        \textbf{Lenguajes}         & C y ensamblador x86                                                  \\
        \textbf{Arquitecturas}     & x86 (32 bits)                                                        \\
        \textbf{Componentes clave} & Kernel, VFS, GUI, gestor de procesos, controladores IDE/SATA        \\
        \textbf{Herramientas}      & GCC, Make, VirtualBox/QEMU                                           \\
        \textbf{Uso educativo}     & Medio: análisis de kernel, GUI y gestión de memoria                  \\
        \hline
    \end{tabular}
    \vspace{1mm} \\
    \textit{Nota. Adaptado de la documentación del sistema Visopsys \cite{visopsys_about, visopsys_scribd}.}
\end{table}

% =========================
% Sistema Operativo: SerenityOS
% =========================
\subsection{SerenityOS}

\subsubsection{Nombre del proyecto o sistema operativo}
SerenityOS es un sistema operativo desarrollado desde cero, orientado a la claridad y consistencia del código, y a ofrecer una experiencia de escritorio con estética retro. Aunque implementa varias interfaces tipo Unix para facilitar el desarrollo y el uso, no deriva de Linux ni de una base Unix existente \cite{serenity_about, serenity_wiki}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio oficial (GitHub): \url{https://github.com/SerenityOS/serenity} \cite{serenity_github}.\\
Sitio web del proyecto: \url{https://serenityos.org} \cite{serenity_about}.\\
Notas y documentación técnica: \url{https://github.com/SerenityOS/serenity/tree/master/Documentation} \cite{serenity_arch}.

\subsubsection{Objetivo del proyecto}
El objetivo de SerenityOS es construir un sistema operativo completo (kernel, librerías, entorno gráfico y aplicaciones) con énfasis en la mantenibilidad y el aprendizaje práctico de ingeniería de sistemas. Además, busca mantener una identidad propia, sin depender de una base de código previa, lo que lo convierte en un entorno útil para estudiar cómo se integra un sistema real desde sus componentes fundamentales \cite{serenity_philosophy, serenity_arch}.

\subsubsection{Lenguajes de implementación}
SerenityOS está desarrollado principalmente en C++ moderno (para kernel, librerías y aplicaciones), además de ensamblador para rutinas de arranque y bajo nivel. El sistema también incluye componentes con JavaScript para partes del stack web y herramientas asociadas \cite{serenity_arch, serenity_github}.

\subsubsection{Arquitectura del sistema}
SerenityOS adopta un diseño de kernel monolítico modular. El núcleo integra los servicios esenciales (planificación, gestión de memoria, interrupciones, controladores y sistema de archivos), manteniendo una organización interna por subsistemas y librerías propias para el espacio de usuario \cite{serenity_arch}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item Gestión de procesos e hilos: multitarea con planificación y primitivas de sincronización en el kernel \cite{serenity_arch}.
    \item Gestión de memoria: memoria virtual con paginación y mecanismos de asignación en kernel y espacio de usuario \cite{serenity_arch}.
    \item Sistema de archivos: capa VFS y utilidades del sistema; el entorno integra herramientas de administración y navegación de archivos \cite{serenity_arch}.
    \item Interfaz gráfica: servidor de ventanas (\textit{WindowServer}) y entorno de escritorio con aplicaciones integradas \cite{serenity_arch}.
    \item Stack web: librerías y herramientas para navegación y renderizado web dentro del ecosistema del proyecto \cite{serenity_github, serenity_arch}.
\end{itemize}

\subsubsection{Herramientas utilizadas}
SerenityOS provee scripts y un flujo de construcción pensado para desarrollo y pruebas en máquina virtual \cite{serenity_arch}.

\begin{itemize}
    \item Compilación y construcción: CMake y Ninja, junto con un toolchain propio generado por el proyecto \cite{serenity_arch}.
    \item Pruebas: ejecución típica sobre QEMU \cite{serenity_arch}.
\end{itemize}

Ejemplo de construcción y ejecución (flujo recomendado):
\begin{verbatim}
git clone https://github.com/SerenityOS/serenity.git
cd serenity
Meta/serenity.sh run
\end{verbatim}

Construcción sin iniciar la VM:
\begin{verbatim}
Meta/serenity.sh build
\end{verbatim}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{figures/serenityos_desktop.png}
    \caption{Escritorio principal de SerenityOS en ejecución.}
    \label{fig:serenityos_desktop}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación y repositorio oficial de SerenityOS \cite{serenity_github, serenity_about}.}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de SerenityOS es medio-alto. Es accesible para estudiantes con base sólida en C/C++ y conceptos de sistemas operativos, porque el proyecto mantiene documentación y una estructura de repositorio que facilita ubicar subsistemas (kernel, librerías, GUI y utilidades) y estudiar su integración \cite{serenity_philosophy, serenity_arch}.

\begin{table}[H]
    \centering
    \caption{Ficha técnica resumida de SerenityOS.}
    \vspace{2mm}
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        Diseño & Kernel monolítico modular, desarrollado desde cero \\ \hline
        Lenguajes & C++ (principal), ensamblador, JavaScript \\
        Arquitecturas & x86\_64 (principal), soporte adicional según toolchain del proyecto \\
        Componentes clave & Kernel, VFS, entorno gráfico, \textit{WindowServer}, herramientas del sistema \\
        Herramientas & CMake, Ninja, toolchain del proyecto, QEMU \\
        Uso educativo & Alto: estudio de arquitectura completa y componentes integrados \\
        \hline
    \end{tabular}
    \vspace{1mm} \\
    \textit{Nota. Adaptado de la documentación oficial de SerenityOS \cite{serenity_about, serenity_arch, serenity_github}.}
\end{table}

% =========================
% Sistema Operativo: ToaruOS
% =========================

\subsection{ToarusOS}
\subsubsection{Nombre del proyecto o sistema operativo}
ToaruOS es un sistema operativo independiente, escrito casi completamente desde cero, diseñado como un recurso educativo que ofrece una implementación completa de un SO moderno.


\subsubsection{Enlace al repositorio y/o documentación oficial}

Repositorio oficial: \url{https://github.com/klange/toaruos}

Sitio web del proyecto: \url{http://toaruos.org/}

\subsubsection{Objetivo del proyecto}
ToarusOS esta diseñado para servir como recurso educativo que permita estudiar y comprender el funcionamiento de un sistema operativo completo. Pretendiendo ser una representación compacta y funcional de los componentes que forman parte de un sistema operativo de escritorio moderno.

\subsubsection{Lenguajes de implementación}
ToaruOS está implementado principalmente en el lenguaje de programación \textbf{C}, además de ello, se encuentra implementado con el lenguaje de programación de Kuroko, un lenguaje propio, un lenguaje de programación dinámico, compilado a bytecode y un dialecto de Python.

\subsubsection{Arquitectura del sistema}
ToaruOS adopta una arquitectura que posee un kernel híbrido y modular, denominada Misaka, es una arquitectura híbrida con módulos cargables en tiempo de ejecución. El kernel proporciona servicios esenciales como la gestión de procesos, memoria y sistemas de archivos, mientras que otros componentes del sistema operativo, como el entorno gráfico y las aplicaciones, se ejecutan en espacio de usuario.

\subsubsection{Componentes implementados}
\begin{itemize}
	\item \textbf{Gestión de procesos e hilos:} ToaruOS ToaruOS utiliza el kernel Misaka, un núcleo híbrido con soporte para multiprocesamiento simétrico (SMP), que implementa un planificador de procesos, mecanismos de comunicación entre procesos mediante el sistema pex y una arquitectura basada en procesos expuestos a través del sistema de archivos virtual \texttt{/proc}.

	\item \textbf{Gestión de memoria: } Incorpora un sistema de memoria  con paginación y asignación dinámica dentro del kernel, complementado por una implementación propia de la biblioteca estándar de C (libc) que administra la memoria en espacio de usuario, junto con el uso de un ramdisk comprimido como sistema de archivos raíz inicial.

	\item \textbf{Sistema de archivos:} ToaruOS emplea un filesystem raíz montado desde un ramdisk e incluye soporte para ISO9660, además de una estructura tipo Unix que integra directorios virtuales como /dev, /proc y /tmp, permitiendo la interacción con dispositivos, procesos y almacenamiento temporal de forma eficiente.

	\item \textbf{Dispositivos y controladores:} El sistema dispone de un conjunto modular de controladores cargables que gestionan dispositivos gráficos, audio, almacenamiento IDE, red y periféricos de entrada, ofreciendo además integración avanzada con entornos de virtualización como VirtualBox y VMware, mientras continúa el desarrollo de drivers adicionales como AHCI, USB y virtio.

	\item \textbf{Interfaz gráfica (GUI):}  ToaruOS cuenta con un entorno gráfico completo basado en Yutani, un servidor de ventanas compositado con aceleración por software y un diseño inspirado en interfaces de finales de los años 2000, acompañado por un conjunto de aplicaciones y herramientas gráficas como la Terminal, el editor Bim y el sistema de widgets TTK.

	\item \textbf{Herramientas de sistema:} Incluye utilidades fundamentales como el shell Esh con soporte para tuberías y redirecciones, el cargador dinámico ld.so, el editor de texto Bim, el lenguaje de programación Kuroko y un conjunto de comandos Unix-like, complementados por herramientas de desarrollo internas como auto-dep.krk.

	\item \textbf{Soporte de hardware:} ToaruOS funciona principalmente sobre arquitecturas x86-64, con soporte experimental para ARMv8 y compatibilidad comprobada tanto en entornos virtualizados como en hardware real, incorporando funcionalidades específicas para mejorar la experiencia en máquinas virtuales y extendiendo continuamente su compatibilidad mediante el desarrollo de nuevos controladores.
\end{itemize}

\subsubsection{Herramientas utilizadas}
ToaruOS utiliza una variedad de herramientas para su desarrollo y compilación, como se detalla a continuación:
\begin{itemize}
	\item \textbf{Compilador:} utilidades estándar de GNU, incluyendo GCC para la compilación del código fuente (makefile)
	\item \textbf{Entorno de prueba:} Compatible con VirtualBox y QEMU para la emulación y prueba del sistema operativo.
	\item \textbf{Misaka Kernel:} El núcleo híbrido de ToaruOS, que proporciona los servicios esenciales del sistema operativo.
	\item \textbf{Yutani:} El servidor de ventanas utilizado para la interfaz gráfica del sistema.
	\item \textbf{Kuroko:}  ToaruOS implementa un lenguaje de scripting propio denominado \textit{Kuroko}, basado en bytecode, que permite a los usuarios escribir scripts dentro del sistema operativo.
	\item Esh Shell: Admite pipes y redirecciones, variables, etc. Proporcionando una interfaz de línea de comandos funcional.
	\item \textbf{Bim Editor:} Un editor de texto ligero y eficiente, diseñado para integrarse perfectamente con el entorno gráfico de ToaruOS.
	\item \textbf{Id.so: } Un cargador dinámico que facilita la ejecución de aplicaciones en el sistema operativo.
	\item \textbf{Terminal:} Una aplicación de terminal que permite a los usuarios interactuar con el sistema operativo a través de la línea de comandos.
	\item \textbf{Instalación y configuración sugerida:} Para instalar y configurar ToaruOS, se recomienda clonar el repositorio oficial y utilizar los scripts de construcción proporcionados:
	    \begin{verbatim}
		git clone https://github.com/klange/toaruos
		cd toaruos
		git submodule update --init kuroko
		docker pull toaruos/build-tools:1.99.x
		docker run -v pwd:/root/misaka -w /root/misaka -e LANG=C.UTF-8 
		-t toaruos/build-tools:1.99.x util/build-in-docker.sh
		\end{verbatim}

    Si se desea compilar localmente en linux, es necesario tener instaladas las herramientas de docker e ingresar al contenedor de docker e inicializar los anteriores comandos con sudo. r
\end{itemize}	

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{figures/toaruos_desktop.png}
    \caption{Escritorio de ToaruOS con el servidor de ventanas \textit{Yutani}. Extraído de la documentación visual del proyecto.}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
ToaruOS presenta una complejidad media-alta, adecuada para estudiantes que ya dominan los fundamentos de C y de sistemas operativos y desean estudiar un sistema de escritorio funcional.

\begin{table}[H]
    \centering
    \caption{Ficha técnica resumida de ToaruOS.}
    \vspace{2mm}
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel híbrido modular con entorno de escritorio propio          \\ \hline
        \textbf{Lenguajes}         & C (principal), lenguaje de scripting Kuroko                      \\
        \textbf{Arquitecturas}     & x86\_64 (principal), ARMv8 experimental                          \\
        \textbf{Componentes clave} & Kernel Misaka, VFS, servidor de ventanas Yutani, shell Esh, Bim  \\
        \textbf{Herramientas}      & GCC, Make, Docker, VirtualBox/QEMU                               \\
        \textbf{Uso educativo}     & Alto: estudio de un sistema de escritorio completo               \\
        \hline
    \end{tabular}
    \vspace{1mm} \\
    \textit{Nota. Adaptado de la documentación oficial del proyecto ToaruOS.}
\end{table}

% ==========================
% Sistema operativo: HaikuOS
% ==========================
\subsection{HaikuOS}
\subsubsection{Nombre del proyecto o sistema operativo}
HaikuOS es un sistema operativo de código abierto inspirado en BeOS, diseñado para ofrecer una experiencia de usuario rápida, eficiente y fácil de usar, especialmente en tareas multimedia y creativas
\subsubsection{Enlace al repositorio y/o documentación oficial}

Repositorio oficial: \url{https://github.com/haiku/haiku}

Sitio web del proyecto y descargas: \url{https://www.haiku-os.org/}

\subsubsection{Objetivo del proyecto}
El objetivo principal de HaikuOS es proporcionar un sistema operativo moderno y eficiente que sea fácil de usar, especialmente para usuarios interesados en aplicaciones multimedia y creativas. HaikuOS busca revivir la filosofía de BeOS, ofreciendo un entorno de escritorio intuitivo y un rendimiento optimizado para tareas que requieren un manejo intensivo de gráficos y multimedia.

\subsubsection{Lenguajes de implementación}
HaikuOS está principalmente implementado en \textbf{C++}, con algunos componentes escritos en \textbf{C} y otros lenguajes según sea necesario para ciertas funcionalidades específicas.

\subsubsection{Arquitectura del sistema}
HaikuOS adopta una arquitectura monolítica modular, donde el núcleo del sistema operativo (kernel) maneja las funciones esenciales, mientras que otros componentes del sistema, como controladores de dispositivos y servicios del sistema, están diseñados como módulos que pueden ser cargados y descargados según sea necesario. Esta arquitectura permite un rendimiento eficiente y una fácil extensibilidad del sistema operativo.

\subsubsection{Componentes implementados}
\begin{itemize}
	\item \textbf{Gestión de procesos e hilos:} HaikuOS implementa un sistema de gestión de procesos y hilos que permite la multitarea preemptiva, facilitando la ejecución simultánea de múltiples aplicaciones y servicios.

	\item \textbf{Gestión de memoria: } HaikuOS utiliza un sistema de gestión de memoria que incluye paginación y segmentación, permitiendo una asignación eficiente de memoria a los procesos y protegiendo la memoria entre ellos.

	\item \textbf{Sistema de archivos:} HaikuOS utiliza el sistema de archivos BFS (Be File System), diseñado para ofrecer un alto rendimiento y soporte para metadatos extensos, facilitando la organización y búsqueda de archivos.

	\item \textbf{Dispositivos y controladores:} HaikuOS incluye una variedad de controladores para gestionar dispositivos de hardware comunes, como tarjetas gráficas, dispositivos de almacenamiento, y periféricos de entrada.

	\item \textbf{Interfaz gráfica (GUI):} HaikuOS cuenta con una interfaz gráfica de usuario intuitiva y fácil de usar, basada en el sistema de ventanas BeOS, que ofrece una experiencia de escritorio coherente y atractiva.

	\item \textbf{Herramientas de sistema:} HaikuOS incluye una serie de herramientas y utilidades del sistema, como un gestor de paquetes, un terminal, y aplicaciones básicas para la gestión del sistema y la administración de archivos.

	\item \textbf{Soporte de hardware:} HaikuOS está diseñado para ser compatible con una amplia gama de hardware, incluyendo arquitecturas x86 y ARM, y continúa expandiendo su soporte para nuevos dispositivos y tecnologías.
\end{itemize}

\subsubsection{Herramientas utilizadas}
HaikuOS utiliza diversas herramientas para su desarrollo y mantenimiento, entre las cuales se incluyen:
\begin{itemize}
	\item \textbf{Compilador:} GCC (GNU Compiler Collection) es la herramienta principal utilizada para compilar el código fuente de HaikuOS.
	\item \textbf{Sistema de construcción:} HaikuOS utiliza un sistema de construcción personalizado basado en Makefiles para gestionar la compilación y el ensamblaje del sistema operativo.
	\item \textbf{Entorno de desarrollo integrado (IDE):} Los desarrolladores de HaikuOS pueden utilizar varios IDEs, como Eclipse o Visual Studio Code, para facilitar el desarrollo y la depuración del código.

	\item \textbf{Depuración y pruebas:} HaikuOS utiliza diversas herramientas de depuración y pruebas, incluyendo GDB (GNU Debugger) y herramientas de		 pruebas automatizadas para asegurar la calidad y estabilidad del sistema operativo.

	\item \textbf{Configuración del proyecto:} HaikuOS proporciona imágenes pre construidas (.ISO) que se descargan desde su sitio web oficial. Donde se pueden arrancar con USB, disco o memoria. También es compatible con máquinas virtuales como VirtualBox, VMware y QEMU para pruebas y desarrollo.
	\item \textbf{Ejecución: } Al iniciar la ISO, se accederá al entorno de instalación.

\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{figures/haikuos_desktop.png}
    \caption{Escritorio de HaikuOS con el explorador de archivos y aplicaciones multimedia.}
\end{figure}

\subsubsection{Nivel de complejidad}
HaikuOS es un sistema operativo de complejidad moderada, debido a su arquitectura modular y su enfoque en la facilidad de uso y el rendimiento. Aunque no es tan complejo como sistemas operativos más grandes como Linux o Windows, HaikuOS ofrece una amplia gama de funcionalidades y características que requieren un conocimiento sólido de los conceptos de sistemas operativos para su desarrollo y mantenimiento. Su diseño modular facilita la comprensión y contribución al proyecto, lo que lo convierte en una opción atractiva para desarrolladores interesados en sistemas operativos.


\begin{table}[H]
    \centering
    \caption{Ficha técnica resumida de HaikuOS.}
    \vspace{2mm}
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico modular inspirado en BeOS        \\ \hline
        \textbf{Lenguajes}         & C++ (principal), C                                  \\
        \textbf{Arquitecturas}     & x86 (principal), ARM en desarrollo                  \\
        \textbf{Componentes clave} & Kernel, BFS, GUI de escritorio, gestor de paquetes  \\
        \textbf{Herramientas}      & GCC, Make, GDB, VirtualBox/VMware/QEMU             \\
        \textbf{Uso educativo}     & Medio: estudio de un escritorio ligero              \\
        \hline
    \end{tabular}
    \vspace{1mm} \\
    \textit{Nota. Adaptado de la documentación oficial de HaikuOS.}
\end{table}

% =========================
% Propuesta 1: xv6
% =========================

\subsection{xv6}

\subsubsection{Nombre del proyecto o sistema operativo}

xv6 es un sistema operativo educativo desarrollado por el MIT como una reimplementación moderna de UNIX Sixth Edition (V6). Su código está diseñado para ser lo más simple posible, permitiendo a los estudiantes estudiar de manera clara la estructura y funcionamiento interno de un sistema operativo real. Se utiliza ampliamente en cursos universitarios avanzados de sistemas operativos, especialmente en el MIT 6.1810/6.828 \cite{xv6_mit_about, xv6_wiki}.

\subsubsection{Enlace al repositorio y/o documentación oficial}

Repositorio oficial (versión RISC-V, actualmente en uso académico):  
\url{https://github.com/mit-pdos/xv6-riscv}

Repositorio histórico para x86:  
\url{https://github.com/mit-pdos/xv6-public}

Documentación del curso MIT 6.1810/6.828:  
\url{https://pdos.csail.mit.edu/6.1810/2024/xv6.html}

Descripción general en Wikipedia:  
\url{https://en.wikipedia.org/wiki/Xv6}

\subsubsection{Objetivo del proyecto}

El objetivo principal de xv6 es \textbf{educativo}. Fue desarrollado para enseñar los conceptos esenciales de un sistema operativo desde su diseño hasta su implementación. xv6 proporciona una arquitectura simple y bien organizada que replica los principios de UNIX V6, pero con código en C moderno y herramientas actuales, facilitando la comprensión del funcionamiento del kernel, el manejo de procesos y la interacción con el hardware \cite{xv6_mit_about, xv6_book}.

Su diseño didáctico permite que los estudiantes puedan modificar o extender el sistema, añadiendo nuevas llamadas al sistema, alterando la planificación o mejorando módulos existentes.

\subsubsection{Lenguajes de implementación}

xv6 está programado principalmente en \textbf{ANSI C}, un lenguaje ideal para estudiar estructuras internas de un OS. Incluye también secciones esenciales en \textbf{ensamblador}, utilizadas para inicializar el procesador, manejar interrupciones del hardware y gestionar el paso al modo protegido (x86) o al modo supervisor (RISC-V). Esta combinación permite desarrollar un kernel real, pero accesible para estudiantes \cite{xv6_book}.

\subsubsection{Arquitectura del sistema}

xv6 implementa un \textbf{kernel monolítico} inspirado en la filosofía de UNIX.  
Todas las funcionalidades esenciales —gestión de procesos, memoria, archivos y controladores mínimos— se encuentran integradas dentro del núcleo, lo que facilita su comprensión y seguimiento.

Actualmente, xv6 está diseñado para ejecutarse principalmente en arquitectura \textbf{RISC-V}, aunque existen versiones previas para x86 de 32 bits \cite{xv6_riscv}.

\subsubsection{Componentes implementados}

xv6 posee todos los elementos fundamentales para ilustrar cómo opera un sistema operativo real:

\begin{itemize}
    \item \textbf{Gestión de procesos:} Implementa \texttt{fork()}, \texttt{exec()}, \texttt{wait()}, señales simples, cambio de contexto y planificación round-robin \cite{xv6_book}.
    
    \item \textbf{Gestión de memoria:} Incluye memoria paginada, asignación dinámica y protección por proceso. En RISC-V utiliza tablas de páginas multinivel.

    \item \textbf{Sistema de archivos:} Posee un sistema basado en i-nodos, con soporte para directorios, enlaces y bloques. Permite comandos como \texttt{ls}, \texttt{mkdir}, \texttt{cat} y \texttt{rm}.

    \item \textbf{Interrupciones y excepciones:} Mecanismo de trampas para manejar llamadas al sistema, interrupciones de hardware y fallos de página.

    \item \textbf{Shell integrado:} Un shell simple escrito en C que soporta pipes, redirecciones y ejecución de comandos básicos.

    \item \textbf{Drivers esenciales:} Controlador de consola, disco virtual y reloj, suficientes para soportar la ejecución en QEMU.
\end{itemize}

Aunque minimalista, xv6 captura la esencia del diseño UNIX y permite extender fácilmente su funcionalidad en entornos educativos.

\subsubsection{Herramientas utilizadas}

El entorno de desarrollo de xv6 se basa en herramientas de sistemas operativos reales:

\begin{itemize}
    \item \textbf{Compilador cruzado para RISC-V:} \texttt{riscv64-unknown-elf-gcc}, requerido para construir el kernel y los programas de usuario.
    \item \textbf{Make y Binutils:} Para automatizar la compilación y enlazado.
    \item \textbf{QEMU:} Emulador recomendado para ejecutar xv6 sin hardware adicional.
    \item \textbf{GDB:} Integrado mediante \texttt{make qemu-gdb} para depuración a nivel de kernel.
\end{itemize}

Ejemplo típico de ejecución:

\begin{verbatim}
make qemu
make qemu-gdb
\end{verbatim}

Estas herramientas permiten estudiar el comportamiento del sistema paso por paso.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{figures/xv6}
    \caption{Interfaz de la terminal del sistema operativo xv6 ejecutándose en el emulador \textit{QEMU}. Extraído de la documentación del curso MIT 6.1810/6.828}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de xv6 es medio. Su código es compacto y muy usado como base de laboratorio en universidades \cite{xv6_book, xv6_wiki}. Esto permite a los estudiantes comprender e implementar mecanismos críticos, como la paginación y la planificación de procesos, en un entorno controlado y manejable sin la sobrecarga de un sistema operativo comercial.
\begin{table}[H]
    \centering
    \caption{Ficha técnica resumida de xv6.}
    \vspace{2mm}
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico inspirado en Unix V6                               \\ \hline
        \textbf{Lenguajes}         & C y ensamblador                                                      \\
        \textbf{Arquitecturas}     & RISC-V (actual), x86 (histórica)                                     \\
        \textbf{Componentes clave} & Procesos, memoria, sistema de archivos, shell, interrupciones        \\
        \textbf{Herramientas}      & GCC RISC-V, Make, QEMU, GDB                                          \\
        \textbf{Uso educativo}     & Muy alto: referencia académica internacional                         \\
        \hline
    \end{tabular}
    \vspace{1mm} \\
    \textit{Nota. Adaptado de la documentación de xv6 y del curso MIT 6.1810/6.828 \cite{xv6_mit_about, xv6_book}.}
\end{table}

% =========================
% Propuesta 2: HobbyOS
% =========================

\subsection{HobbyOS}

\subsubsection{Nombre del proyecto o sistema operativo}

HobbyOS es un sistema operativo experimental desarrollado como un proyecto personal para explorar el diseño de kernels, la estructura interna de un sistema operativo y la interacción directa con el hardware. A diferencia de sistemas educativos consolidados como xv6, HobbyOS se encuentra en una fase más temprana, con un enfoque en proveer un entorno minimalista para aprender cómo construir un OS desde cero. Está orientado principalmente a desarrolladores principiantes interesados en comprender los fundamentos del arranque, el manejo básico de memoria y la arquitectura x86\_64 \cite{hobbyos_repo, hobbyos_topics}.

\subsubsection{Enlace al repositorio y/o documentación oficial}

Repositorio oficial del proyecto:  
\url{https://github.com/ObadiahCrowe/HobbyOS}

Colección de sistemas “hobby OS” relacionados en GitHub (contexto educativo):  
\url{https://github.com/topics/hobby-os}

\subsubsection{Objetivo del proyecto}

El objetivo principal de HobbyOS es \textbf{experimental y educativo}. El proyecto busca ofrecer un entorno minimalista que permita estudiar el proceso de construcción de un kernel desde su etapa más básica: configuración del compilador cruzado, arranque del sistema, implementación de rutinas en ensamblador y la estructura esencial de un núcleo operativo.

Su propósito es brindar un punto de partida accesible para estudiantes y entusiastas que desean comprender cómo funciona un sistema operativo a nivel interno, sin la complejidad de sistemas avanzados como Linux o BSD \cite{hobbyos_repo}.

\subsubsection{Lenguajes de implementación}

HobbyOS está escrito principalmente en \textbf{C}, con secciones de \textbf{ensamblador x86\_64} necesarias para realizar el proceso de arranque (bootloader), manejar interrupciones básicas y configurar los registros y el modo protegido o de 64 bits. Esta combinación de C y ensamblador es típica en sistemas operativos minimalistas, ya que permite interactuar directamente con el hardware al mismo tiempo que se mantiene un código relativamente claro y modular \cite{hobbyos_repo}.

\subsubsection{Arquitectura del sistema}

Aunque la documentación oficial no califica explícitamente su arquitectura como monolítica o microkernel, el diseño mostrado en su repositorio indica un \textbf{kernel monolítico simple}. Es decir, el núcleo contiene la mayor parte de las funcionalidades disponibles: rutinas de memoria, interrupciones básicas y control inicial del hardware.

El sistema está dirigido a la arquitectura \textbf{x86\_64} moderna, lo cual lo diferencia de varios sistemas educativos clásicos que utilizan x86 de 32 bits. Esto permite estudiar una arquitectura actual y ampliamente utilizada \cite{hobbyos_repo}.

\subsubsection{Componentes implementados}

HobbyOS se encuentra en desarrollo activo y por ello sus componentes son básicos, pero suficientes para fines de aprendizaje:

\begin{itemize}
    \item \textbf{Bootloader personalizado:} Incluye código en ensamblador para realizar el proceso de arranque, cambiar a modo de 64 bits y cargar el kernel en memoria.
    
    \item \textbf{Kernel mínimo:} Provee estructuras para inicializar el sistema, configurar la pila, manejar el entorno básico del CPU y ejecutar código C dentro del kernel.

    \item \textbf{Gestión temprana de memoria:} Implementa rutinas simples para administrar memoria, configurar memoria física disponible y organizar el espacio del sistema.

    \item \textbf{Interrupciones básicas:} Define tablas de interrupciones e incluye manejadores mínimos, necesarios para extender funcionalidades en versiones futuras.

    \item \textbf{Interfaz textual:} La salida a consola se realiza mediante rutinas de escritura directa en memoria de video (modo texto), útil para depuración y pruebas.

    \item \textbf{Compatibilidad con QEMU:} Puede iniciarse mediante una imagen de arranque compatible con QEMU, lo cual simplifica las pruebas de kernel sin requerir hardware físico.
\end{itemize}

Aunque el sistema carece todavía de un conjunto completo de procesos, memoria virtual o sistema de archivos, esto es intencional: busca ser una base de estudio extremadamente clara y progresiva.

\subsubsection{Herramientas utilizadas}

El desarrollo de HobbyOS requiere un conjunto de herramientas específicas para trabajar con kernels de bajo nivel:

\begin{itemize}
    \item \textbf{Compilador cruzado x86\_64-elf-gcc:} Necesario para producir binarios adecuados a un entorno sin sistema operativo.
    \item \textbf{Binutils para x86\_64:} Incluye ensambladores como \texttt{as}, enlazadores (\texttt{ld}) y herramientas para manipular binarios.
    \item \textbf{NASM u otro ensamblador:} Utilizado para el código de arranque.
    \item \textbf{QEMU:} Emulador recomendado para ejecutar el sistema sin hardware físico.
    \item \textbf{Make:} Orquestación del proceso de compilación y generación de imágenes de disco.
\end{itemize}

Ejemplo de compilación típica en el entorno del proyecto:

\begin{verbatim}
make
qemu-system-x86_64 -kernel hobbyos.bin
\end{verbatim}

Estas herramientas permiten a los estudiantes observar cada etapa del proceso de construcción de un sistema operativo.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{figures/HobbyOSbasiccmd.png}
    \caption{Sesión de consola de HobbyOS mostrando comandos básicos del kernel. Extraído del repositorio oficial del proyecto}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de HobbyOS es bajo-medio, ideal para quienes desean comprender los primeros pasos en el diseño de kernels \cite{hobbyos_topics}. Al carecer de la vasta infraestructura de los sistemas operativos comerciales, permite a los desarrolladores centrarse en entender cómo el software toma control inicial del hardware sin distraerse con abstracciones complejas.

\begin{table}[H]
    \centering
    \caption{Ficha técnica resumida de HobbyOS.}
    \vspace{2mm}
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico minimalista                             \\ \hline
        \textbf{Lenguajes}         & C y ensamblador x86\_64                                   \\
        \textbf{Arquitecturas}     & x86\_64                                                   \\
        \textbf{Componentes clave} & Bootloader, kernel básico, memoria inicial, interrupciones \\
        \textbf{Herramientas}      & GCC cruzado, NASM, QEMU, Make                             \\
        \textbf{Uso educativo}     & Alto: estudio de arranque y estructura básica             \\
        \hline
    \end{tabular}
    \vspace{1mm} \\
    \textit{Nota. Adaptado de la descripción del proyecto HobbyOS en GitHub \cite{hobbyos_repo, hobbyos_topics}.}
\end{table}

% =========================
% Sistema Operativo: MikeOS
% =========================
\subsection{MikeOS}

\subsubsection{Nombre del proyecto o sistema operativo}

MikeOS es un sistema operativo didáctico de 16 bits, minimalista y de código abierto, creado expresamente para demostrar los fundamentos de un sistema operativo sencillo operando en modo real. A diferencia de los núcleos modernos que buscan abstraer el hardware mediante capas complejas, MikeOS expone deliberadamente la arquitectura subyacente del PC, permitiendo a los estudiantes interactuar directamente con la BIOS y los registros del procesador. Es un proyecto maduro y bien documentado que sirve como una introducción ideal para quienes desean aprender lenguaje ensamblador x86 y entender cómo una computadora arranca y ejecuta programas sin la ayuda de bibliotecas estándar o sistemas operativos anfitriones \cite{mikeos_about}.

\subsubsection{Enlace al repositorio y/o documentación oficial}

Sitio web oficial y descargas:  
\url{https://mikeos.sourceforge.net/} \cite{mikeos_about}

Documentación y manuales técnicos:  
\url{https://mikeos.sourceforge.net/doc.html} \cite{mikeos_purpose}

\subsubsection{Objetivo del proyecto}

El objetivo principal de MikeOS es **educativo y de demostración**. El proyecto busca desmitificar el funcionamiento de bajo nivel de las computadoras personales enseñando ensamblador x86 de 16 bits y la implementación de llamadas al sistema en un kernel simple y comprensible.

Su propósito no es competir con sistemas operativos de escritorio, sino proporcionar un "cajón de arena" (sandbox) donde los desarrolladores noveles puedan escribir código que controle la máquina directamente, aprendiendo sobre interrupciones, manejo de memoria y E/S de disco de una forma que los sistemas operativos protegidos modernos no permiten \cite{mikeos_purpose}.

\subsubsection{Lenguajes de implementación}

MikeOS está implementado casi por completo en **ensamblador x86 de 16 bits (NASM)**, una elección de diseño fundamental para garantizar el control total sobre el hardware y el tamaño reducido del código. Además, el sistema incluye un intérprete de **BASIC** integrado, el cual permite a los usuarios escribir y ejecutar programas sencillos sin necesidad de reensamblar el kernel. Esta dualidad ofrece dos niveles de aprendizaje: la crudeza del ensamblador para el desarrollo del sistema y la simplicidad de BASIC para la creación rápida de aplicaciones \cite{mikeos_source, mikeos_architecture}.

\subsubsection{Arquitectura del sistema}

El sistema presenta una arquitectura **monolítica en modo real**, lo que significa que no existe distinción entre el espacio del núcleo y el del usuario, ni protección de memoria. El kernel, el shell y los programas de usuario comparten un único espacio de memoria direccionable de 64 KB (segmento único).

Aunque esta arquitectura es obsoleta para la computación comercial moderna, es perfecta para el aprendizaje, ya que elimina la complejidad de la gestión de memoria virtual, la paginación y los anillos de protección, permitiendo al estudiante visualizar todo el mapa de memoria del sistema de un solo vistazo \cite{mikeos_architecture}.

\subsubsection{Componentes implementados}

MikeOS, a pesar de su tamaño reducido, cuenta con un conjunto robusto de componentes que emulan la funcionalidad de sistemas más grandes:

\begin{itemize}
    \item \textbf{Kernel Monolítico:} Es el núcleo del sistema, encargado de la inicialización del hardware, la gestión de vectores de interrupción y la provisión de una API para los programas.
    
    \item \textbf{Bootloader (Cargador de arranque):} Un pequeño programa en el sector de arranque encargado de cargar el núcleo desde un disquete (o imagen de disco) a la memoria RAM y transferirle el control.

    \item \textbf{API de Llamadas al sistema:} El kernel expone más de 60 funciones documentadas para manejo de cadenas, operaciones matemáticas, gráficos básicos y acceso a disco, facilitando la vida al programador de aplicaciones.

    \item \textbf{Shell (Intérprete de comandos):} Una interfaz de línea de comandos (CLI) que permite al usuario navegar por el disco, ejecutar programas y gestionar archivos de manera interactiva.

    \item \textbf{Intérprete de BASIC:} Un componente distintivo que permite la ejecución de scripts en tiempo real, similar a las computadoras hogareñas de los años 80.
\end{itemize}

Esta estructura modular permite a los estudiantes modificar una parte específica, como el cargador de arranque o un comando del shell, sin romper necesariamente el resto del sistema.

\subsubsection{Herramientas utilizadas}

Para compilar, probar y desarrollar sobre MikeOS se utiliza un conjunto estándar de herramientas de código abierto, accesibles tanto en Linux como en Windows:

\begin{itemize}
    \item \textbf{Ensamblador NASM:} Es la herramienta principal utilizada para convertir el código fuente `.asm` en código máquina binario crudo.
    \item \textbf{Emuladores (QEMU o Bochs):} Permiten ejecutar y depurar el sistema operativo en una ventana virtual, simulando el hardware de un PC x86 antiguo.
    \item \textbf{Herramientas de imagen de disco:} Utilidades como `dd` o `mkisofs` para crear las imágenes de disquete o CD booteables.
    \item \textbf{Editor de texto simple:} Al no requerir un IDE complejo, cualquier editor de código es suficiente para trabajar con los archivos fuente.
\end{itemize}

Ejemplo de cómo se ensambla y ejecuta típicamente el kernel:

\begin{verbatim}
nasm -f bin -o mikeos.flp source/bootload/bootload.asm
qemu-system-i386 -fda mikeos.flp
\end{verbatim}

Estas herramientas son ligeras y enseñan al estudiante el flujo de trabajo clásico del desarrollo de sistemas embebidos o de bajo nivel.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/mikeos_interface.png}
    \caption{Editor de texto de MikeOS mostrando un programa de demostración en BASIC. Extraído del sitio oficial del proyecto}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad es **bajo a medio-bajo**, lo que convierte a MikeOS en uno de los sistemas más accesibles para introducirse en el mundo del ensamblador y los fundamentos de los sistemas operativos \cite{mikeos_purpose}. Al operar en modo real y evitar abstracciones modernas, la curva de aprendizaje se centra puramente en la lógica del hardware y el flujo de control, sin las barreras que imponen sistemas más avanzados. Es, en esencia, la puerta de entrada perfecta antes de saltar a arquitecturas de 32 o 64 bits.

\begin{table}[H]
    \centering
    \caption{Ficha técnica resumida de MikeOS.}
    \vspace{2mm}
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico simple en modo real de 16 bits   \\ \hline
        \textbf{Lenguajes}         & Ensamblador x86 (NASM), BASIC                      \\
        \textbf{Arquitecturas}     & x86 (16 bits)                                      \\
        \textbf{Componentes clave} & Kernel, bootloader, llamadas al sistema, BASIC     \\
        \textbf{Herramientas}      & NASM, QEMU/Bochs                                   \\
        \textbf{Uso educativo}     & Muy alto: introducción a ensamblador y SO simples  \\
        \hline
    \end{tabular}
    \vspace{1mm} \\
    \textit{Nota. Adaptado de la documentación oficial de MikeOS \cite{mikeos_about, mikeos_purpose, mikeos_architecture}.}
\end{table}

% =========================
% Sistema Operativo: BareMetal OS
% =========================
\subsection{BareMetal OS}

\subsubsection{Nombre del proyecto o sistema operativo}
BareMetal OS (BMOS) es un sistema operativo de código abierto diseñado para ejecutarse directamente sobre hardware \textit{bare metal} en sistemas x86-64. El proyecto se define como un sistema basado en \textit{exokernel}, orientado a exponer recursos de hardware a las aplicaciones y reducir la sobrecarga típica de sistemas operativos tradicionales \cite{bmos_purpose, bmos_source}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio del proyecto (código y guía de construcción): \url{https://github.com/ReturnInfinity/BareMetal-OS} \cite{bmos_purpose, bmos_architecture}.

\subsubsection{Objetivo del proyecto}
El objetivo de BareMetal OS es experimental y de nicho: ofrecer un entorno de muy bajo nivel para ejecutar aplicaciones con control cercano al hardware, priorizando flexibilidad y eficiencia bajo el enfoque \textit{exokernel} \cite{bmos_purpose}.

\subsubsection{Lenguajes de implementación}
El sistema está desarrollado principalmente en ensamblador x86-64. Además, el repositorio contempla la construcción de aplicaciones en C/C++ (por ejemplo, demos o utilidades), usando GCC como compilador de apoyo \cite{bmos_source, bmos_purpose}.

\subsubsection{Arquitectura del sistema}
BareMetal OS adopta un enfoque \textit{exokernel}: el núcleo mantiene un diseño minimalista y busca exponer recursos de hardware a las aplicaciones para permitir optimizaciones específicas por tarea. El proyecto está enfocado en plataformas x86-64 multinúcleo \cite{bmos_architecture, bmos_purpose}.

\subsubsection{Componentes implementados}
Según la estructura descrita en el repositorio, BareMetal OS se organiza en componentes principales \cite{bmos_purpose}:
\begin{itemize}
    \item \textit{Pure64}: cargador (loader) del sistema.
    \item \textit{BareMetal}: kernel del sistema.
    \item \textit{Monitor}: interfaz simple de línea de comandos.
    \item \textit{BMFS}: utilidad asociada al \textit{BareMetal File System}.
    \item \textit{BareMetal-Demo}: colección de programas de demostración.
\end{itemize}

\subsubsection{Herramientas utilizadas}
El repositorio incluye un flujo de trabajo automatizado con el script \texttt{baremetal.sh}, que permite preparar, compilar e iniciar el sistema en máquina virtual \cite{bmos_purpose}. En general se emplean:
\begin{itemize}
    \item NASM (ensamblador) para compilar el cargador, kernel y aplicaciones en ensamblador.
    \item QEMU para pruebas rápidas en virtualización.
    \item GCC para compilar aplicaciones en C/C++ (cuando aplique).
    \item Git para obtener el código fuente.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/bmos_interface.png}
    \caption{BareMetal OS ejecutándose en entorno virtual, mostrando su interfaz tipo consola. Extraído del repositorio del proyecto}
    \label{fig:bmos_interface}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de BareMetal OS es medio-alto, ya que su estudio requiere bases sólidas de arquitectura x86-64 y programación de bajo nivel. Es más adecuado para escenarios avanzados, donde se busca comprender la interacción directa con el hardware y el enfoque \textit{exokernel} \cite{bmos_wiki, bmos_purpose}.

\begin{table}[H]
    \centering
    \caption{Ficha técnica resumida de BareMetal OS.}
    \vspace{2mm}
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        Diseño & Sistema basado en \textit{exokernel} orientado a ejecución \textit{bare metal} \\ \hline
        Lenguajes & Ensamblador x86-64 (principal) y soporte para C/C++ en utilidades/demos \\
        Arquitecturas & x86-64 \\
        Componentes clave & \textit{Pure64}, \textit{BareMetal} (kernel), \textit{Monitor}, \textit{BMFS}, demos \\
        Herramientas & NASM, QEMU, GCC, Git (flujo con \texttt{baremetal.sh}) \\
        Uso educativo & Avanzado: programación de bajo nivel y estudio de enfoque \textit{exokernel} \\
        \hline
    \end{tabular}
    \vspace{1mm} \\
    \textit{Nota. Adaptado del repositorio y documentación del proyecto BareMetal OS \cite{bmos_purpose, bmos_architecture}.}
\end{table}

% =========================
% Sistema Operativo: PintOS
% =========================
\subsection{PintOS}

\subsubsection{Nombre del proyecto o sistema operativo}
PintOS es un \textit{framework} de sistema operativo minimalista orientado a la enseñanza, diseñado para la arquitectura x86 de 32 bits. Se emplea ampliamente en cursos universitarios porque proporciona un código base deliberadamente incompleto que permite a los estudiantes implementar y comprender, de forma guiada, los componentes centrales de un sistema operativo \cite{pintos_stanford, pintos_source}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Documentación académica base (Stanford): \url{https://web.stanford.edu/class/cs140/projects/pintos/pintos_1.html} \cite{pintos_stanford}.

Guía de desarrollo y material complementario: \url{https://github.com/SajedHassan/CSEx61-pintos} \cite{pintos_purpose}.

\subsubsection{Objetivo del proyecto}
El objetivo de PintOS es estrictamente educativo. Su finalidad es que el estudiante construya progresivamente un sistema operativo funcional a partir de un esqueleto inicial, implementando hilos, sincronización, soporte de programas de usuario, llamadas al sistema, memoria virtual y un sistema de archivos. En ese sentido, PintOS funciona como un laboratorio estructurado donde cada entrega añade capacidades reales al kernel y obliga a justificar decisiones de diseño \cite{pintos_purpose, pintos_stanford}.

\subsubsection{Lenguajes de implementación}
El núcleo y la mayor parte del código están implementados en C. Las rutinas de más bajo nivel, necesarias para el arranque, manejo de interrupciones y cambios de contexto, se implementan en ensamblador x86. Además, el entorno de construcción y automatización incluye scripts auxiliares, típicamente escritos en Perl \cite{pintos_source}.

\subsubsection{Arquitectura del sistema}
PintOS utiliza un diseño monolítico académico para x86 de 32 bits: las funciones principales (planificación, sincronización, manejo de memoria, llamadas al sistema y sistema de archivos) residen en el kernel. Sin embargo, su enfoque no es “dar un SO terminado”, sino ofrecer una arquitectura sencilla y controlada para que el alumno integre módulos por etapas, manteniendo un flujo de trabajo repetible de compilación, ejecución y prueba en emuladores \cite{pintos_stanford}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/pintos_qem.png}
    \caption{Componentes del Sistema Operativo PintOS. Extraído del repositorio del proyecto}
    \label{fig:pintos-qemu}
\end{figure}

\subsubsection{Componentes implementados}
PintOS se organiza típicamente en cuatro bloques de trabajo que estructuran el aprendizaje:

\begin{itemize}
    \item \textbf{Threads:} implementación y gestión de hilos, primitivas de sincronización (bloqueos, semáforos, condiciones) y políticas básicas de planificación.
    \item \textbf{User Programs:} carga de ejecutables, manejo de argumentos y construcción de la interfaz de llamadas al sistema entre espacio de usuario y kernel.
    \item \textbf{Virtual Memory:} soporte de paginación, tratamiento de fallos de página, y mecanismos que permiten que los procesos administren memoria de forma más realista.
    \item \textbf{File System:} construcción de un sistema de archivos funcional con soporte de directorios, persistencia en disco y operaciones típicas de lectura/escritura.
\end{itemize}

\subsubsection{Herramientas utilizadas}
El flujo de trabajo está pensado para entornos GNU/Linux, usando herramientas estándar:

\begin{itemize}
    \item \textbf{Compilación:} GCC y utilidades de binarios (\texttt{binutils}), con automatización mediante \texttt{make}.
    \item \textbf{Depuración:} GDB para inspección y depuración a nivel de kernel.
    \item \textbf{Pruebas y ejecución:} emulación en \textit{QEMU} o \textit{Bochs}, lo que permite iterar rápidamente sin hardware dedicado \cite{pintos_stanford}.
\end{itemize}


\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de PintOS es medio-alto. Aunque su diseño es intencionalmente simple en comparación con sistemas operativos de producción, el estudiante debe implementar conceptos críticos que suelen ser difíciles: sincronización correcta, interfaz de llamadas al sistema, paginación y persistencia en disco. Su accesibilidad es alta para fines académicos porque el proyecto está ampliamente documentado, estructurado en etapas y respaldado por materiales docentes \cite{pintos_stanford, pintos_purpose}.

\begin{table}[H]
    \centering
    \caption{Ficha técnica resumida de PintOS.}
    \vspace{2mm}
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico académico para x86 de 32 bits \\ \hline
        \textbf{Lenguajes}         & C, ensamblador x86, Perl (scripts) \\
        \textbf{Arquitecturas}     & x86 (32 bits) \\
        \textbf{Componentes clave} & Hilos, llamadas al sistema, memoria virtual, sistema de archivos \\
        \textbf{Herramientas}      & GCC, Make, Perl, QEMU/Bochs, GDB \\
        \textbf{Uso educativo}     & Muy alto: base estructurada para cursos universitarios \\
        \hline
    \end{tabular}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación académica de PintOS \cite{pintos_stanford, pintos_purpose}.}
\end{table}
