\section{Propuestas Analizadas}

% =========================
% Propuesta 1: HelenOS
% =========================
\subsection{HelenOS}

\subsubsection{Nombre del proyecto o sistema operativo}
HelenOS es un sistema operativo multiserver basado en un microkernel, desarrollado completamente desde cero y sin dependencia de Unix. Su diseño busca la modularidad, la portabilidad y la tolerancia a fallos, orientado principalmente a la investigación académica y la enseñanza de arquitectura de sistemas operativos \cite{helenos_about}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio oficial: \url{https://github.com/HelenOS/helenos}.

Sitio web del proyecto: \url{https://www.helenos.org}.

Documentación técnica (PDF): \url{https://www.helenos.org/doc/prjdoc.pdf}

\subsubsection{Objetivo del proyecto}
El objetivo de HelenOS es principalmente educativo y experimental. Su propósito es servir como plataforma de estudio de sistemas operativos modernos, promoviendo un enfoque modular donde cada servicio (sistema de archivos, red, controladores o interfaz gráfica) se implementa como un servidor independiente en espacio de usuario. Este diseño fomenta el análisis de conceptos avanzados como la comunicación entre procesos (IPC) y la separación entre el núcleo y los servicios de usuario \cite{helenos_about, helenos_prjdoc}.

\subsubsection{Lenguajes de implementación}
El proyecto está desarrollado principalmente en el lenguaje C, con partes críticas escritas en ensamblador (para el arranque del sistema y la gestión de interrupciones). Se mantiene compatibilidad con los estándares C11 y C++14, lo que facilita la portabilidad y la integración de nuevos componentes \cite{helenos_prjdoc}.

\subsubsection{Arquitectura del sistema}
HelenOS adopta una arquitectura de microkernel multiserver. El microkernel proporciona únicamente los servicios esenciales —planificación, gestión de memoria, interrupciones e IPC— mientras que todos los demás servicios (como el sistema de archivos, la red o la interfaz gráfica) se ejecutan como procesos de usuario independientes que se comunican mediante paso de mensajes (\textit{message passing}) \cite{helenos_prjdoc}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Gestión de procesos e hilos:} soporte de multitarea con planificación por prioridades y aislamiento entre procesos. El modelo de ejecución permite múltiples hilos por proceso y comunicación sincronizada entre ellos mediante IPC.
    \item \textbf{Gestión de memoria:} sistema de memoria virtual con paginación y protección por espacio de direcciones. El kernel se encarga de la asignación básica y los servidores de usuario gestionan asignadores dinámicos (\textit{slab allocators}) y regiones compartidas.
    \item \textbf{Sistema de archivos (VFS):} arquitectura de VFS donde cada tipo de sistema de archivos (por ejemplo, FAT, EXT2) se implementa como un servidor separado en espacio de usuario, permitiendo montar y desmontar sistemas de archivos sin reiniciar el núcleo.
    \item \textbf{Dispositivos y controladores:} \textit{drivers} en espacio de usuario, lo que evita que errores en controladores afecten la estabilidad general del sistema. Hay soporte para dispositivos de almacenamiento, red, USB, vídeo, teclado y ratón.
    \item \textbf{Sistema de red:} pila TCP/IP modular con soporte para IPv4, interfaces Ethernet virtuales y utilidades de diagnóstico como \texttt{ping}, \texttt{netstat}, \texttt{inet list-addr} y \texttt{arp}.
    \item \textbf{Sistema gráfico:} entorno gráfico de ventanas (GUI) que corre completamente en espacio de usuario, con aplicaciones como \textit{Terminal}, \textit{Text Editor}, \textit{Navigator}, \textit{Calculator}, \textit{GFX Demo} y \textit{Tetris}.
    \item \textbf{Comunicación e IPC:} sistema de comunicación entre procesos mediante intercambio de mensajes orientado a puertos.
    \item \textbf{Seguridad y aislamiento:} cada componente ejecuta con privilegios mínimos, lo que mejora la tolerancia a fallos.
    \item \textbf{Portabilidad:} soporte para \texttt{ia32}, \texttt{amd64}, \texttt{arm32}, \texttt{mips32}, \texttt{ppc32}, \texttt{sparc64} e \texttt{ia64}.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Toolchain cruzado:} generado mediante \texttt{tools/toolchain.sh}, que compila \texttt{gcc}, \texttt{binutils} y \texttt{gdb} adaptados a HelenOS.
    \item \textbf{Meson y Ninja:} sistema de construcción y generador de compilaciones incrementales.
    \item \textbf{Dependencias:} paquetes como \texttt{build-essential}, \texttt{wget}, \texttt{texinfo}, \texttt{flex}, \texttt{bison}, \texttt{dialog}, \texttt{python3-yaml} y \texttt{genisoimage}.
    \item \textbf{Emulación y prueba:} ejecución en \textit{QEMU} o \textit{VirtualBox}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{figures/helenos_toolchain.png}
    \caption{Elaboración propia. Compilación cruzada del script \texttt{toolchain.sh} del proyecto HelenOS.}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de HelenOS es alto, ya que su comprensión requiere conocimientos de compilación cruzada, IPC y gestión de memoria. Sin embargo, su estructura modular y la documentación disponible lo convierten en una herramienta didáctica sólida \cite{helenos_docs, manek2018}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Microkernel multiserver modular                                     \\ \hline
        \textbf{Lenguajes}         & C (principal) y ensamblador                                         \\
        \textbf{Arquitecturas}     & ia32, amd64, arm32, mips32, ppc32, sparc64                          \\
        \textbf{Componentes clave} & Kernel mínimo, VFS, red, GUI, controladores en espacio de usuario   \\
        \textbf{Herramientas}      & GCC (toolchain cruzado), Meson, Ninja, QEMU/VirtualBox              \\
        \textbf{Uso educativo}     & Alto: análisis modular de componentes e IPC                         \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de HelenOS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de ``About HelenOS'' \cite{helenos_about}.}
\end{table}

% =========================
% Propuesta 2: Visopsys
% =========================
\subsection{Visopsys}

\subsubsection{Nombre del proyecto o sistema operativo}
Visopsys (\textit{Visual Operating System}) es un sistema operativo alternativo, gratuito y desarrollado desde cero por Andy McLaughlin desde 1997. No está basado en Unix ni en Linux, sino que implementa su propio kernel, gestor de archivos y entorno gráfico \cite{visopsys_about}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio y descargas: \url{https://sourceforge.net/projects/visopsys/files/} \cite{visopsys_sourceforge}.

Sitio web del proyecto: \url{https://visopsys.org} \cite{visopsys_about}.

Presentación técnica: \url{https://es.scribd.com/presentation/619552414/SO-visopsys} \cite{visopsys_scribd}.

\subsubsection{Objetivo del proyecto}
Visopsys tiene un objetivo principalmente educativo y experimental. Proporciona una plataforma funcional para demostrar principios de diseño de sistemas operativos, gestión de procesos, memoria y sistemas de archivos \cite{visopsys_scribd}.

\subsubsection{Lenguajes de implementación}
Está implementado principalmente en C, con secciones críticas en ensamblador x86 \cite{visopsys_sourceforge}.

\subsubsection{Arquitectura del sistema}
Visopsys implementa una arquitectura monolítica modular: el núcleo controla procesos, memoria, sistema de archivos y controladores, pero permite carga dinámica de módulos \cite{visopsys_about}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Gestión de procesos e hilos:} multitarea cooperativa y por prioridades.
    \item \textbf{Gestión de memoria:} memoria virtual simple con asignación dinámica y aislamiento básico.
    \item \textbf{Sistema de archivos:} soporte para FAT12, FAT16 y FAT32, con detección de particiones MBR y GPT.
    \item \textbf{Dispositivos y controladores:} controladores para discos IDE/SATA, vídeo en modo VESA, teclado, ratón y USB.
    \item \textbf{Interfaz gráfica:} entorno con ventanas, menús y barra de herramientas, con administrador de archivos, editor de texto y visor hexadecimal.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Compilador:} GCC y utilidades GNU (\texttt{make}, \texttt{binutils}).
    \item \textbf{Entorno de prueba:} \textit{VirtualBox} y \textit{QEMU}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/visopsys_gui.png}
    \caption{Entorno de escritorio de Visopsys ejecutado en máquina virtual. Extraído del sitio oficial del proyecto.}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de Visopsys es medio. Su estructura modular permite estudiar planificación, memoria, controladores y GUI en un único entorno funcional \cite{visopsys_scribd}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico modular con GUI integrada                         \\ \hline
        \textbf{Lenguajes}         & C y ensamblador x86                                                  \\
        \textbf{Arquitecturas}     & x86 (32 bits)                                                        \\
        \textbf{Componentes clave} & Kernel, VFS, GUI, gestor de procesos, controladores IDE/SATA        \\
        \textbf{Herramientas}      & GCC, Make, VirtualBox/QEMU                                           \\
        \textbf{Uso educativo}     & Medio: análisis de kernel, GUI y gestión de memoria                  \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de Visopsys.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación del sistema Visopsys \cite{visopsys_about, visopsys_scribd}.}
\end{table}

% =========================
% Sistema Operativo: SerenityOS
% =========================
\subsection{SerenityOS}

\subsubsection{Nombre del proyecto o sistema operativo}
SerenityOS es un sistema operativo desarrollado desde cero, con énfasis en la claridad del código y en la recreación de una experiencia de escritorio similar a los entornos clásicos de los años noventa \cite{serenity_about, serenity_wiki}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio oficial (GitHub): \url{https://github.com/SerenityOS/serenity} \cite{serenity_github}.

Sitio web del proyecto: \url{https://serenityos.org} \cite{serenity_about}.

\subsubsection{Objetivo del proyecto}
El proyecto busca construir un sistema operativo y entorno gráfico coherente, con:

\begin{itemize}
    \item código claro y consistente,
    \item entorno de escritorio completo,
    \item enfoque en el aprendizaje de ingeniería de sistemas,
    \item independencia de bases de código Unix o Linux \cite{serenity_philosophy}.
\end{itemize}

\subsubsection{Lenguajes de implementación}
SerenityOS está desarrollado principalmente en C++20; utiliza además ensamblador para rutinas de bajo nivel y JavaScript en el navegador \textit{Ladybird} \cite{serenity_arch}.

\subsubsection{Arquitectura del sistema}
Adopta un kernel monolítico modular que implementa procesos, hilos, memoria virtual, sistema de archivos, controladores de dispositivos, interrupciones y mecanismos sencillos de IPC \cite{serenity_arch}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Kernel Serenity:} núcleo monolítico con planificación y memoria virtual.
    \item \textbf{Sistema de archivos:} VFS con soporte para permisos e inodos.
    \item \textbf{Interfaz gráfica:} servidor de ventanas \textit{WindowServer} y escritorio completo.
    \item \textbf{Navegador Ladybird:} motor propio para HTML, CSS y JavaScript.
    \item \textbf{Aplicaciones:} editor de texto, administrador de archivos, terminal, calculadora y herramientas de desarrollo.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Compiladores:} GCC o Clang.
    \item \textbf{Construcción:} CMake y \textit{Ninja}.
    \item \textbf{Toolchain propio:} \texttt{serenity-toolchain}.
    \item \textbf{Pruebas:} ejecución en \textit{QEMU}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{figures/serenityos_desktop.png}
    \caption{Escritorio principal de SerenityOS ejecutado en QEMU. Extraído del repositorio oficial del proyecto}
    \label{fig:serenityos_desktop}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de SerenityOS es medio-alto. Su organización y estilo de código permiten estudiar kernels monolíticos modernos, sistemas de archivos y construcción de una GUI desde cero \cite{serenity_philosophy, serenity_arch}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico escrito desde cero                                \\ \hline
        \textbf{Lenguajes}         & C++20 (principal), ensamblador, JavaScript                          \\
        \textbf{Arquitecturas}     & x86\_64                                                              \\
        \textbf{Componentes clave} & Kernel, GUI, WindowServer, VFS propio, navegador Ladybird           \\
        \textbf{Herramientas}      & CMake, Ninja, GCC/Clang, QEMU                                       \\
        \textbf{Uso educativo}     & Alto: estudio de kernel, GUI y C++ moderno                          \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de SerenityOS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación oficial de SerenityOS \cite{serenity_about, serenity_arch}.}
\end{table}

% =========================
% Sistema Operativo: ToaruOS
% =========================
\subsection{ToaruOS}

\subsubsection{Nombre del proyecto o sistema operativo}
ToaruOS es un sistema operativo independiente, escrito casi por completo desde cero, que ofrece una implementación compacta pero funcional de un sistema de escritorio moderno.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio oficial: \url{https://github.com/klange/toaruos}

Sitio web del proyecto: \url{http://toaruos.org/}

\subsubsection{Objetivo del proyecto}
ToaruOS está orientado a facilitar el estudio de un sistema operativo completo, desde el kernel hasta la interfaz de usuario gráfica.

\subsubsection{Lenguajes de implementación}
ToaruOS está implementado principalmente en C e integra el lenguaje \textit{Kuroko}, un lenguaje dinámico compilado a \textit{bytecode} usado para scripting y herramientas internas.

\subsubsection{Arquitectura del sistema}
El sistema adopta una arquitectura con kernel híbrido y modular denominada \textit{Misaka}, con soporte para multiprocesamiento simétrico y módulos cargables.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Gestión de procesos e hilos:} kernel \textit{Misaka} con SMP y mecanismos de IPC.
    \item \textbf{Gestión de memoria:} paginación y asignación dinámica, más un \textit{ramdisk} comprimido como sistema raíz.
    \item \textbf{Sistema de archivos:} estructura tipo Unix con directorios virtuales como \texttt{/dev}, \texttt{/proc} y \texttt{/tmp}.
    \item \textbf{Interfaz gráfica:} servidor de ventanas \textit{Yutani}, con aplicaciones como la Terminal, el editor \textit{Bim} y el sistema de widgets \textit{TTK}.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Compilador:} herramientas GNU, incluyendo GCC y \texttt{make}.
    \item \textbf{Entorno de prueba:} \textit{VirtualBox} y \textit{QEMU}.
    \item \textbf{Construcción en contenedor:} uso habitual de \textit{Docker} para compilar el sistema.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{figures/toaruos_desktop.png}
    \caption{Escritorio de ToaruOS con el servidor de ventanas \textit{Yutani}. Extraído de la documentación visual del proyecto.}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
ToaruOS presenta una complejidad media-alta, adecuada para estudiantes que ya dominan los fundamentos de C y de sistemas operativos y desean estudiar un sistema de escritorio funcional.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel híbrido modular con entorno de escritorio propio          \\ \hline
        \textbf{Lenguajes}         & C (principal), lenguaje de scripting Kuroko                      \\
        \textbf{Arquitecturas}     & x86\_64 (principal), ARMv8 experimental                          \\
        \textbf{Componentes clave} & Kernel Misaka, VFS, servidor de ventanas Yutani, shell Esh, Bim  \\
        \textbf{Herramientas}      & GCC, Make, Docker, VirtualBox/QEMU                               \\
        \textbf{Uso educativo}     & Alto: estudio de un sistema de escritorio completo               \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de ToaruOS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación oficial del proyecto ToaruOS.}
\end{table}

% =========================
% Sistema Operativo: HaikuOS
% =========================
\subsection{HaikuOS}

\subsubsection{Nombre del proyecto o sistema operativo}
HaikuOS es un sistema operativo de código abierto inspirado en BeOS, diseñado para ofrecer una experiencia rápida, eficiente y orientada a tareas multimedia y creativas.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio oficial: \url{https://github.com/haiku/haiku}

Sitio web del proyecto: \url{https://www.haiku-os.org/}

\subsubsection{Objetivo del proyecto}
HaikuOS busca revivir la filosofía de BeOS, proporcionando un entorno de escritorio moderno y sencillo de usar con buen rendimiento en aplicaciones multimedia.

\subsubsection{Lenguajes de implementación}
HaikuOS está implementado principalmente en C++, con partes en C y otros lenguajes para componentes específicos.

\subsubsection{Arquitectura del sistema}
Adopta una arquitectura monolítica modular: el kernel gestiona procesos, memoria e interrupciones, mientras que servicios y controladores se implementan como módulos cargables.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Gestión de procesos e hilos:} multitarea con hilos ligeros y planificación preemptiva.
    \item \textbf{Gestión de memoria:} paginación y protección entre procesos.
    \item \textbf{Sistema de archivos:} Be File System (BFS) con metadatos extensos e índices.
    \item \textbf{Interfaz gráfica:} escritorio inspirado en BeOS con un conjunto de aplicaciones integradas.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Compilador:} GCC.
    \item \textbf{Sistema de construcción:} \texttt{Makefiles} y herramientas propias.
    \item \textbf{Entornos de prueba:} \textit{VirtualBox}, \textit{VMware} y \textit{QEMU}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{figures/haikuos_desktop.png}
    \caption{Escritorio de HaikuOS con el explorador de archivos y aplicaciones multimedia.}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
HaikuOS presenta una complejidad moderada y es útil para estudiar el diseño de un entorno de escritorio ligero orientado a multimedia.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico modular inspirado en BeOS        \\ \hline
        \textbf{Lenguajes}         & C++ (principal), C                                  \\
        \textbf{Arquitecturas}     & x86 (principal), ARM en desarrollo                  \\
        \textbf{Componentes clave} & Kernel, BFS, GUI de escritorio, gestor de paquetes  \\
        \textbf{Herramientas}      & GCC, Make, GDB, VirtualBox/VMware/QEMU             \\
        \textbf{Uso educativo}     & Medio: estudio de un escritorio ligero              \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de HaikuOS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación oficial de HaikuOS.}
\end{table}

% =========================
% Sistema Operativo: xv6
% =========================
\subsection{xv6}

\subsubsection{Nombre del proyecto o sistema operativo}
xv6 es un sistema operativo educativo desarrollado por el MIT como una reimplementación moderna de Unix Sixth Edition (V6). Se utiliza ampliamente en cursos universitarios avanzados de sistemas operativos \cite{xv6_mit_about, xv6_wiki}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio principal (RISC-V): \url{https://github.com/mit-pdos/xv6-riscv} \cite{xv6_riscv}.

Repositorio histórico x86: \url{https://github.com/mit-pdos/xv6-public}.

Documentación del curso MIT 6.1810/6.828: \url{https://pdos.csail.mit.edu/6.1810/2024/xv6.html} \cite{xv6_mit_about}.

\subsubsection{Objetivo del proyecto}
El objetivo de xv6 es educativo: explicar los conceptos esenciales de un sistema operativo mediante un kernel pequeño y legible \cite{xv6_book}.

\subsubsection{Lenguajes de implementación}
xv6 está escrito principalmente en C, con partes en ensamblador para inicialización de procesador, interrupciones y cambio de modo \cite{xv6_book}.

\subsubsection{Arquitectura del sistema}
Implementa un kernel monolítico inspirado en Unix. Actualmente se enfoca en arquitectura RISC-V, con versiones previas para x86 \cite{xv6_riscv}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Gestión de procesos:} \texttt{fork()}, \texttt{exec()}, \texttt{wait()} y planificación \textit{round-robin}.
    \item \textbf{Gestión de memoria:} memoria paginada con tablas de páginas multinivel.
    \item \textbf{Sistema de archivos:} sistema con i-nodos, directorios, enlaces y comandos básicos.
    \item \textbf{Shell:} shell simple con tuberías y redirecciones.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Compilador:} \texttt{riscv64-unknown-elf-gcc}.
    \item \textbf{Construcción:} \texttt{make} y \textit{binutils}.
    \item \textbf{Pruebas:} \textit{QEMU} y \textit{GDB}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{figures/xv6}
    \caption{Interfaz de la terminal del sistema operativo xv6 ejecutándose en el emulador \textit{QEMU}. Extraído de la documentación del curso MIT 6.1810/6.828}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de xv6 es medio. Su código es compacto y muy usado como base de laboratorio en universidades \cite{xv6_book, xv6_wiki}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico inspirado en Unix V6                               \\ \hline
        \textbf{Lenguajes}         & C y ensamblador                                                      \\
        \textbf{Arquitecturas}     & RISC-V (actual), x86 (histórica)                                     \\
        \textbf{Componentes clave} & Procesos, memoria, sistema de archivos, shell, interrupciones        \\
        \textbf{Herramientas}      & GCC RISC-V, Make, QEMU, GDB                                          \\
        \textbf{Uso educativo}     & Muy alto: referencia académica internacional                         \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de xv6.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación de xv6 y del curso MIT 6.1810/6.828 \cite{xv6_mit_about, xv6_book}.}
\end{table}

% =========================
% Sistema Operativo: HobbyOS
% =========================
\subsection{HobbyOS}

\subsubsection{Nombre del proyecto o sistema operativo}
HobbyOS es un sistema operativo experimental desarrollado como proyecto personal para explorar el diseño de kernels y la interacción directa con el hardware \cite{hobbyos_repo, hobbyos_topics}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio oficial: \url{https://github.com/ObadiahCrowe/HobbyOS} \cite{hobbyos_repo}.

Colección de proyectos afines: \url{https://github.com/topics/hobby-os} \cite{hobbyos_topics}.

\subsubsection{Objetivo del proyecto}
Su objetivo es experimental y educativo: servir como base sencilla para estudiar el proceso de construcción de un kernel desde sus primeras etapas.

\subsubsection{Lenguajes de implementación}
HobbyOS está escrito principalmente en C, con secciones en ensamblador x86\_64 para el \textit{bootloader}, interrupciones y configuración inicial \cite{hobbyos_repo}.

\subsubsection{Arquitectura del sistema}
El diseño corresponde a un kernel monolítico simple orientado a arquitectura x86\_64.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Bootloader:} código en ensamblador que prepara el entorno de 64 bits y carga el kernel.
    \item \textbf{Kernel mínimo:} inicialización del sistema, pila y ejecución de código C.
    \item \textbf{Memoria temprana:} rutinas simples para administrar memoria física.
    \item \textbf{Interrupciones:} tablas y manejadores iniciales.
    \item \textbf{Salida de texto:} escritura directa en memoria de vídeo en modo texto.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Compilador cruzado:} \texttt{x86\_64-elf-gcc}.
    \item \textbf{Ensamblador:} NASM.
    \item \textbf{Pruebas:} \textit{QEMU} y \texttt{make}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{figures/HobbyOSbasiccmd.png}
    \caption{Sesión de consola de HobbyOS mostrando comandos básicos del kernel. Extraído del repositorio oficial del proyecto}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de HobbyOS es bajo-medio, ideal para quienes desean comprender los primeros pasos en el diseño de kernels \cite{hobbyos_topics}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico minimalista                             \\ \hline
        \textbf{Lenguajes}         & C y ensamblador x86\_64                                   \\
        \textbf{Arquitecturas}     & x86\_64                                                   \\
        \textbf{Componentes clave} & Bootloader, kernel básico, memoria inicial, interrupciones \\
        \textbf{Herramientas}      & GCC cruzado, NASM, QEMU, Make                             \\
        \textbf{Uso educativo}     & Alto: estudio de arranque y estructura básica             \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de HobbyOS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la descripción del proyecto HobbyOS en GitHub \cite{hobbyos_repo, hobbyos_topics}.}
\end{table}

% =========================
% Sistema Operativo: MikeOS
% =========================
\subsection{MikeOS}

\subsubsection{Nombre del proyecto o sistema operativo}
MikeOS es un sistema operativo didáctico de 16 bits, minimalista y de código abierto, creado para demostrar los fundamentos de un sistema operativo sencillo en modo real \cite{mikeos_about}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Sitio web oficial y descargas: \url{https://mikeos.sourceforge.net/} \cite{mikeos_about}.

Documentación y manuales: \url{https://mikeos.sourceforge.net/doc.html} \cite{mikeos_purpose}.

\subsubsection{Objetivo del proyecto}
Su objetivo es educativo: enseñar ensamblador x86 de 16 bits y la implementación de llamadas al sistema en un kernel simple \cite{mikeos_purpose}.

\subsubsection{Lenguajes de implementación}
MikeOS está implementado casi por completo en ensamblador x86 de 16 bits (NASM), e incluye un intérprete de BASIC \cite{mikeos_source, mikeos_architecture}.

\subsubsection{Arquitectura del sistema}
Presenta una arquitectura monolítica en modo real, donde kernel, shell y programas comparten un espacio de memoria de 64 KB \cite{mikeos_architecture}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Kernel:} inicialización, interrupciones y carga de programas.
    \item \textbf{Bootloader:} carga del núcleo desde disquete o imagen.
    \item \textbf{Llamadas al sistema:} más de 60 funciones de E/S.
    \item \textbf{Shell:} intérprete de línea de comandos.
    \item \textbf{Intérprete de BASIC:} ejecución de programas básicos.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Ensamblador:} NASM.
    \item \textbf{Pruebas:} QEMU o Bochs.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/mikeos_interface.png}
    \caption{Editor de texto de MikeOS mostrando un programa de demostración en BASIC. Extraído del sitio oficial del proyecto}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad es bajo a medio-bajo, y es uno de los sistemas más accesibles para introducirse en ensamblador y fundamentos de sistemas operativos \cite{mikeos_purpose}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico simple en modo real de 16 bits   \\ \hline
        \textbf{Lenguajes}         & Ensamblador x86 (NASM), BASIC                      \\
        \textbf{Arquitecturas}     & x86 (16 bits)                                      \\
        \textbf{Componentes clave} & Kernel, bootloader, llamadas al sistema, BASIC     \\
        \textbf{Herramientas}      & NASM, QEMU/Bochs                                   \\
        \textbf{Uso educativo}     & Muy alto: introducción a ensamblador y SO simples  \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de MikeOS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación oficial de MikeOS \cite{mikeos_about, mikeos_purpose, mikeos_architecture}.}
\end{table}

% =========================
% Sistema Operativo: BareMetal OS
% =========================
\subsection{BareMetal OS}

\subsubsection{Nombre del proyecto o sistema operativo}
BareMetal OS (BMOS) es un sistema operativo de código abierto diseñado para ejecutarse directamente sobre el hardware (\textit{bare metal}) en arquitecturas x86-64 \cite{bmos_wiki}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio histórico: \url{https://github.com/ReturnInfinity/BareMetal-OS} \cite{bmos_purpose, bmos_source, bmos_architecture}.

\subsubsection{Objetivo del proyecto}
Su objetivo es experimental y de nicho: proporcionar un entorno para ejecutar aplicaciones \textit{bare metal} de alto rendimiento sin la sobrecarga de un sistema operativo completo \cite{bmos_purpose}.

\subsubsection{Lenguajes de implementación}
BareMetal OS está implementado casi en su totalidad en ensamblador x86-64 \cite{bmos_source}.

\subsubsection{Arquitectura del sistema}
Presenta una arquitectura monolítica y monotarea para x86-64, con soporte multiprocesador \cite{bmos_architecture}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Kernel minimalista:} núcleo muy pequeño que inicializa hardware y carga aplicaciones.
    \item \textbf{Soporte multiprocesador:} capacidad de aprovechar múltiples CPU.
    \item \textbf{Primitivas de E/S:} funciones básicas para entrada y salida.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Ensambladores x86-64:} como NASM.
    \item \textbf{Pruebas:} QEMU y Bochs.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/bmos_interface.png}
    \caption{BareMetal OS ejecutándose en QEMU con una aplicación tipo consola. Extraído del repositorio histórico del proyecto}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad es medio-alto, adecuado para estudios avanzados de programación \textit{bare metal} \cite{bmos_wiki}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico minimalista, bare metal, monotarea/multiprocesador \\ \hline
        \textbf{Lenguajes}         & Ensamblador x86-64                                                   \\
        \textbf{Arquitecturas}     & x86-64                                                               \\
        \textbf{Componentes clave} & Kernel pequeño, soporte APIC/SMP, E/S básica                         \\
        \textbf{Herramientas}      & Ensambladores 64 bits, QEMU/Bochs                                    \\
        \textbf{Uso educativo}     & Avanzado: estudio de x86-64 y programación bare metal                \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de BareMetal OS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación y repositorio de BareMetal OS \cite{bmos_wiki, bmos_purpose, bmos_architecture}.}
\end{table}

% =========================
% Sistema Operativo: PintOS
% =========================
\subsection{PintOS}

\subsubsection{Nombre del proyecto o sistema operativo}
PintOS es un framework de sistema operativo minimalista diseñado para la arquitectura x86, utilizado principalmente en cursos universitarios de sistemas operativos \cite{pintos_stanford, pintos_source}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Documentación del proyecto: \url{https://web.stanford.edu/class/cs140/projects/pintos/pintos_1.html} \cite{pintos_stanford, pintos_source}.

Guía de desarrollo: \url{https://github.com/SajedHassan/CSEx61-pintos} \cite{pintos_purpose}.

\subsubsection{Objetivo del proyecto}
El objetivo de PintOS es educativo: proporcionar una base incompleta que los estudiantes deben extender implementando hilos, llamadas al sistema, memoria virtual y sistema de archivos \cite{pintos_purpose}.

\subsubsection{Lenguajes de implementación}
El código base está escrito principalmente en C, con rutinas de bajo nivel en ensamblador x86 \cite{pintos_source}. Algunos scripts auxiliares utilizan Perl.

\subsubsection{Arquitectura del sistema}
PintOS adopta una arquitectura monolítica simple para x86 de 32 bits. Se ejecuta en modo kernel y sirve como marco para cuatro grandes proyectos académicos \cite{pintos_stanford}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Threads:} hilos, sincronización y planificación.
    \item \textbf{User Programs:} carga de ejecutables y capa de llamadas al sistema.
    \item \textbf{Virtual Memory:} paginación y manejo de fallos de página.
    \item \textbf{File System:} sistema de archivos con directorios y manejo de disco.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Compilador:} GCC.
    \item \textbf{Construcción:} \texttt{make} y \texttt{binutils}.
    \item \textbf{Depuración:} GDB.
    \item \textbf{Pruebas:} QEMU o Bochs.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/pintos_qemu.png}
    \caption{PintOS ejecutándose en QEMU durante una práctica de laboratorio. Extraído de la documentación académica del proyecto}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad es medio-alto. PintOS obliga a implementar conceptos críticos como sincronización, memoria virtual y sistema de archivos, y cuenta con abundante documentación y soporte académico \cite{pintos_stanford, pintos_purpose}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico académico para x86 de 32 bits       \\ \hline
        \textbf{Lenguajes}         & C, ensamblador x86, Perl (scripts)                    \\
        \textbf{Arquitecturas}     & x86 (32 bits)                                         \\
        \textbf{Componentes clave} & Hilos, llamadas al sistema, memoria virtual, sistema de archivos \\
        \textbf{Herramientas}      & GCC, Make, Perl, QEMU/Bochs, GDB                      \\
        \textbf{Uso educativo}     & Muy alto: base en cursos de sistemas operativos       \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de PintOS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación oficial del proyecto PintOS \cite{pintos_stanford, pintos_purpose}.}
\end{table}
