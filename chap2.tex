\section{Propuestas Analizadas}

% =========================
% Propuesta 1: HelenOS
% =========================
\subsection{HelenOS}

\subsubsection{Nombre del proyecto o sistema operativo}
HelenOS es un sistema operativo multiserver basado en un microkernel, desarrollado completamente desde cero y sin dependencia de Unix. Su diseño busca la modularidad, la portabilidad y la tolerancia a fallos, orientado principalmente a la investigación académica y la enseñanza de arquitectura de sistemas operativos \cite{helenos_about}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio oficial: \url{https://github.com/HelenOS/helenos}.

Sitio web del proyecto: \url{https://www.helenos.org}.

Documentación técnica (PDF): \url{https://www.helenos.org/doc/prjdoc.pdf}

\subsubsection{Objetivo del proyecto}
El objetivo de HelenOS es principalmente educativo y experimental. Su propósito es servir como plataforma de estudio de sistemas operativos modernos, promoviendo un enfoque modular donde cada servicio (sistema de archivos, red, controladores o interfaz gráfica) se implementa como un servidor independiente en espacio de usuario. Este diseño fomenta el análisis de conceptos avanzados como la comunicación entre procesos (IPC) y la separación entre el núcleo y los servicios de usuario \cite{helenos_about, helenos_prjdoc}.

\subsubsection{Lenguajes de implementación}
El proyecto está desarrollado principalmente en el lenguaje C, con partes críticas escritas en ensamblador (para el arranque del sistema y la gestión de interrupciones). Se mantiene compatibilidad con los estándares C11 y C++14, lo que facilita la portabilidad y la integración de nuevos componentes \cite{helenos_prjdoc}.

\subsubsection{Arquitectura del sistema}
HelenOS adopta una arquitectura de microkernel multiserver. El microkernel proporciona únicamente los servicios esenciales —planificación, gestión de memoria, interrupciones e IPC— mientras que todos los demás servicios (como el sistema de archivos, la red o la interfaz gráfica) se ejecutan como procesos de usuario independientes que se comunican mediante paso de mensajes (\textit{message passing}) \cite{helenos_prjdoc}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Gestión de procesos e hilos:} soporte de multitarea con planificación por prioridades y aislamiento entre procesos. El modelo de ejecución permite múltiples hilos por proceso y comunicación sincronizada entre ellos mediante IPC.
    \item \textbf{Gestión de memoria:} sistema de memoria virtual con paginación y protección por espacio de direcciones. El kernel se encarga de la asignación básica y los servidores de usuario gestionan asignadores dinámicos (\textit{slab allocators}) y regiones compartidas.
    \item \textbf{Sistema de archivos (VFS):} arquitectura de VFS donde cada tipo de sistema de archivos (por ejemplo, FAT, EXT2) se implementa como un servidor separado en espacio de usuario, permitiendo montar y desmontar sistemas de archivos sin reiniciar el núcleo.
    \item \textbf{Dispositivos y controladores:} \textit{drivers} en espacio de usuario, lo que evita que errores en controladores afecten la estabilidad general del sistema. Hay soporte para dispositivos de almacenamiento, red, USB, vídeo, teclado y ratón.
    \item \textbf{Sistema de red:} pila TCP/IP modular con soporte para IPv4, interfaces Ethernet virtuales y utilidades de diagnóstico como \texttt{ping}, \texttt{netstat}, \texttt{inet list-addr} y \texttt{arp}.
    \item \textbf{Sistema gráfico:} entorno gráfico de ventanas (GUI) que corre completamente en espacio de usuario, con aplicaciones como \textit{Terminal}, \textit{Text Editor}, \textit{Navigator}, \textit{Calculator}, \textit{GFX Demo} y \textit{Tetris}.
    \item \textbf{Comunicación e IPC:} sistema de comunicación entre procesos mediante intercambio de mensajes orientado a puertos.
    \item \textbf{Seguridad y aislamiento:} cada componente ejecuta con privilegios mínimos, lo que mejora la tolerancia a fallos.
    \item \textbf{Portabilidad:} soporte para \texttt{ia32}, \texttt{amd64}, \texttt{arm32}, \texttt{mips32}, \texttt{ppc32}, \texttt{sparc64} e \texttt{ia64}.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Toolchain cruzado:} generado mediante \texttt{tools/toolchain.sh}, que compila \texttt{gcc}, \texttt{binutils} y \texttt{gdb} adaptados a HelenOS.
    \item \textbf{Meson y Ninja:} sistema de construcción y generador de compilaciones incrementales.
    \item \textbf{Dependencias:} paquetes como \texttt{build-essential}, \texttt{wget}, \texttt{texinfo}, \texttt{flex}, \texttt{bison}, \texttt{dialog}, \texttt{python3-yaml} y \texttt{genisoimage}.
    \item \textbf{Emulación y prueba:} ejecución en \textit{QEMU} o \textit{VirtualBox}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{figures/helenos_toolchain.png}
    \caption{Elaboración propia. Compilación cruzada del script \texttt{toolchain.sh} del proyecto HelenOS.}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de HelenOS es alto, ya que su comprensión requiere conocimientos de compilación cruzada, IPC y gestión de memoria. Sin embargo, su estructura modular y la documentación disponible lo convierten en una herramienta didáctica sólida \cite{helenos_docs, manek2018}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Microkernel multiserver modular                                     \\ \hline
        \textbf{Lenguajes}         & C (principal) y ensamblador                                         \\
        \textbf{Arquitecturas}     & ia32, amd64, arm32, mips32, ppc32, sparc64                          \\
        \textbf{Componentes clave} & Kernel mínimo, VFS, red, GUI, controladores en espacio de usuario   \\
        \textbf{Herramientas}      & GCC (toolchain cruzado), Meson, Ninja, QEMU/VirtualBox              \\
        \textbf{Uso educativo}     & Alto: análisis modular de componentes e IPC                         \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de HelenOS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de ``About HelenOS'' \cite{helenos_about}.}
\end{table}

% =========================
% Propuesta 2: Visopsys
% =========================
\subsection{Visopsys}

\subsubsection{Nombre del proyecto o sistema operativo}
Visopsys (\textit{Visual Operating System}) es un sistema operativo alternativo, gratuito y desarrollado desde cero por Andy McLaughlin desde 1997. No está basado en Unix ni en Linux, sino que implementa su propio kernel, gestor de archivos y entorno gráfico \cite{visopsys_about}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio y descargas: \url{https://sourceforge.net/projects/visopsys/files/} \cite{visopsys_sourceforge}.

Sitio web del proyecto: \url{https://visopsys.org} \cite{visopsys_about}.

Presentación técnica: \url{https://es.scribd.com/presentation/619552414/SO-visopsys} \cite{visopsys_scribd}.

\subsubsection{Objetivo del proyecto}
Visopsys tiene un objetivo principalmente educativo y experimental. Proporciona una plataforma funcional para demostrar principios de diseño de sistemas operativos, gestión de procesos, memoria y sistemas de archivos \cite{visopsys_scribd}.

\subsubsection{Lenguajes de implementación}
Está implementado principalmente en C, con secciones críticas en ensamblador x86 \cite{visopsys_sourceforge}.

\subsubsection{Arquitectura del sistema}
Visopsys implementa una arquitectura monolítica modular: el núcleo controla procesos, memoria, sistema de archivos y controladores, pero permite carga dinámica de módulos \cite{visopsys_about}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Gestión de procesos e hilos:} multitarea cooperativa y por prioridades.
    \item \textbf{Gestión de memoria:} memoria virtual simple con asignación dinámica y aislamiento básico.
    \item \textbf{Sistema de archivos:} soporte para FAT12, FAT16 y FAT32, con detección de particiones MBR y GPT.
    \item \textbf{Dispositivos y controladores:} controladores para discos IDE/SATA, vídeo en modo VESA, teclado, ratón y USB.
    \item \textbf{Interfaz gráfica:} entorno con ventanas, menús y barra de herramientas, con administrador de archivos, editor de texto y visor hexadecimal.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Compilador:} GCC y utilidades GNU (\texttt{make}, \texttt{binutils}).
    \item \textbf{Entorno de prueba:} \textit{VirtualBox} y \textit{QEMU}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/visopsys_gui.png}
    \caption{Entorno de escritorio de Visopsys ejecutado en máquina virtual. Extraído del sitio oficial del proyecto.}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de Visopsys es medio. Su estructura modular permite estudiar planificación, memoria, controladores y GUI en un único entorno funcional \cite{visopsys_scribd}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico modular con GUI integrada                         \\ \hline
        \textbf{Lenguajes}         & C y ensamblador x86                                                  \\
        \textbf{Arquitecturas}     & x86 (32 bits)                                                        \\
        \textbf{Componentes clave} & Kernel, VFS, GUI, gestor de procesos, controladores IDE/SATA        \\
        \textbf{Herramientas}      & GCC, Make, VirtualBox/QEMU                                           \\
        \textbf{Uso educativo}     & Medio: análisis de kernel, GUI y gestión de memoria                  \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de Visopsys.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación del sistema Visopsys \cite{visopsys_about, visopsys_scribd}.}
\end{table}

% =========================
% Sistema Operativo: SerenityOS
% =========================
\subsection{SerenityOS}

\subsubsection{Nombre del proyecto o sistema operativo}
SerenityOS es un sistema operativo desarrollado desde cero, con énfasis en la claridad del código y en la recreación de una experiencia de escritorio similar a los entornos clásicos de los años noventa \cite{serenity_about, serenity_wiki}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio oficial (GitHub): \url{https://github.com/SerenityOS/serenity} \cite{serenity_github}.

Sitio web del proyecto: \url{https://serenityos.org} \cite{serenity_about}.

\subsubsection{Objetivo del proyecto}
El proyecto busca construir un sistema operativo y entorno gráfico coherente, con:

\begin{itemize}
    \item código claro y consistente,
    \item entorno de escritorio completo,
    \item enfoque en el aprendizaje de ingeniería de sistemas,
    \item independencia de bases de código Unix o Linux \cite{serenity_philosophy}.
\end{itemize}

\subsubsection{Lenguajes de implementación}
SerenityOS está desarrollado principalmente en C++20; utiliza además ensamblador para rutinas de bajo nivel y JavaScript en el navegador \textit{Ladybird} \cite{serenity_arch}.

\subsubsection{Arquitectura del sistema}
Adopta un kernel monolítico modular que implementa procesos, hilos, memoria virtual, sistema de archivos, controladores de dispositivos, interrupciones y mecanismos sencillos de IPC \cite{serenity_arch}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Kernel Serenity:} núcleo monolítico con planificación y memoria virtual.
    \item \textbf{Sistema de archivos:} VFS con soporte para permisos e inodos.
    \item \textbf{Interfaz gráfica:} servidor de ventanas \textit{WindowServer} y escritorio completo.
    \item \textbf{Navegador Ladybird:} motor propio para HTML, CSS y JavaScript.
    \item \textbf{Aplicaciones:} editor de texto, administrador de archivos, terminal, calculadora y herramientas de desarrollo.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Compiladores:} GCC o Clang.
    \item \textbf{Construcción:} CMake y \textit{Ninja}.
    \item \textbf{Toolchain propio:} \texttt{serenity-toolchain}.
    \item \textbf{Pruebas:} ejecución en \textit{QEMU}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{figures/serenityos_desktop.png}
    \caption{Escritorio principal de SerenityOS ejecutado en QEMU. Extraído del repositorio oficial del proyecto}
    \label{fig:serenityos_desktop}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de SerenityOS es medio-alto. Su organización y estilo de código permiten estudiar kernels monolíticos modernos, sistemas de archivos y construcción de una GUI desde cero \cite{serenity_philosophy, serenity_arch}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico escrito desde cero                                \\ \hline
        \textbf{Lenguajes}         & C++20 (principal), ensamblador, JavaScript                          \\
        \textbf{Arquitecturas}     & x86\_64                                                              \\
        \textbf{Componentes clave} & Kernel, GUI, WindowServer, VFS propio, navegador Ladybird           \\
        \textbf{Herramientas}      & CMake, Ninja, GCC/Clang, QEMU                                       \\
        \textbf{Uso educativo}     & Alto: estudio de kernel, GUI y C++ moderno                          \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de SerenityOS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación oficial de SerenityOS \cite{serenity_about, serenity_arch}.}
\end{table}

% =========================
% Sistema Operativo: ToaruOS
% =========================
\subsection{ToaruOS}

\subsubsection{Nombre del proyecto o sistema operativo}
ToaruOS es un sistema operativo independiente, escrito casi por completo desde cero, que ofrece una implementación compacta pero funcional de un sistema de escritorio moderno.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio oficial: \url{https://github.com/klange/toaruos}

Sitio web del proyecto: \url{http://toaruos.org/}

\subsubsection{Objetivo del proyecto}
ToaruOS está orientado a facilitar el estudio de un sistema operativo completo, desde el kernel hasta la interfaz de usuario gráfica.

\subsubsection{Lenguajes de implementación}
ToaruOS está implementado principalmente en C e integra el lenguaje \textit{Kuroko}, un lenguaje dinámico compilado a \textit{bytecode} usado para scripting y herramientas internas.

\subsubsection{Arquitectura del sistema}
El sistema adopta una arquitectura con kernel híbrido y modular denominada \textit{Misaka}, con soporte para multiprocesamiento simétrico y módulos cargables.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Gestión de procesos e hilos:} kernel \textit{Misaka} con SMP y mecanismos de IPC.
    \item \textbf{Gestión de memoria:} paginación y asignación dinámica, más un \textit{ramdisk} comprimido como sistema raíz.
    \item \textbf{Sistema de archivos:} estructura tipo Unix con directorios virtuales como \texttt{/dev}, \texttt{/proc} y \texttt{/tmp}.
    \item \textbf{Interfaz gráfica:} servidor de ventanas \textit{Yutani}, con aplicaciones como la Terminal, el editor \textit{Bim} y el sistema de widgets \textit{TTK}.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Compilador:} herramientas GNU, incluyendo GCC y \texttt{make}.
    \item \textbf{Entorno de prueba:} \textit{VirtualBox} y \textit{QEMU}.
    \item \textbf{Construcción en contenedor:} uso habitual de \textit{Docker} para compilar el sistema.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{figures/toaruos_desktop.png}
    \caption{Escritorio de ToaruOS con el servidor de ventanas \textit{Yutani}. Extraído de la documentación visual del proyecto.}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
ToaruOS presenta una complejidad media-alta, adecuada para estudiantes que ya dominan los fundamentos de C y de sistemas operativos y desean estudiar un sistema de escritorio funcional.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel híbrido modular con entorno de escritorio propio          \\ \hline
        \textbf{Lenguajes}         & C (principal), lenguaje de scripting Kuroko                      \\
        \textbf{Arquitecturas}     & x86\_64 (principal), ARMv8 experimental                          \\
        \textbf{Componentes clave} & Kernel Misaka, VFS, servidor de ventanas Yutani, shell Esh, Bim  \\
        \textbf{Herramientas}      & GCC, Make, Docker, VirtualBox/QEMU                               \\
        \textbf{Uso educativo}     & Alto: estudio de un sistema de escritorio completo               \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de ToaruOS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación oficial del proyecto ToaruOS.}
\end{table}

% =========================
% Sistema Operativo: HaikuOS
% =========================
\subsection{HaikuOS}

\subsubsection{Nombre del proyecto o sistema operativo}
HaikuOS es un sistema operativo de código abierto inspirado en BeOS, diseñado para ofrecer una experiencia rápida, eficiente y orientada a tareas multimedia y creativas.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio oficial: \url{https://github.com/haiku/haiku}

Sitio web del proyecto: \url{https://www.haiku-os.org/}

\subsubsection{Objetivo del proyecto}
HaikuOS busca revivir la filosofía de BeOS, proporcionando un entorno de escritorio moderno y sencillo de usar con buen rendimiento en aplicaciones multimedia.

\subsubsection{Lenguajes de implementación}
HaikuOS está implementado principalmente en C++, con partes en C y otros lenguajes para componentes específicos.

\subsubsection{Arquitectura del sistema}
Adopta una arquitectura monolítica modular: el kernel gestiona procesos, memoria e interrupciones, mientras que servicios y controladores se implementan como módulos cargables.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Gestión de procesos e hilos:} multitarea con hilos ligeros y planificación preemptiva.
    \item \textbf{Gestión de memoria:} paginación y protección entre procesos.
    \item \textbf{Sistema de archivos:} Be File System (BFS) con metadatos extensos e índices.
    \item \textbf{Interfaz gráfica:} escritorio inspirado en BeOS con un conjunto de aplicaciones integradas.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Compilador:} GCC.
    \item \textbf{Sistema de construcción:} \texttt{Makefiles} y herramientas propias.
    \item \textbf{Entornos de prueba:} \textit{VirtualBox}, \textit{VMware} y \textit{QEMU}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{figures/haikuos_desktop.png}
    \caption{Escritorio de HaikuOS con el explorador de archivos y aplicaciones multimedia.}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
HaikuOS presenta una complejidad moderada y es útil para estudiar el diseño de un entorno de escritorio ligero orientado a multimedia.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico modular inspirado en BeOS        \\ \hline
        \textbf{Lenguajes}         & C++ (principal), C                                  \\
        \textbf{Arquitecturas}     & x86 (principal), ARM en desarrollo                  \\
        \textbf{Componentes clave} & Kernel, BFS, GUI de escritorio, gestor de paquetes  \\
        \textbf{Herramientas}      & GCC, Make, GDB, VirtualBox/VMware/QEMU             \\
        \textbf{Uso educativo}     & Medio: estudio de un escritorio ligero              \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de HaikuOS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación oficial de HaikuOS.}
\end{table}

% =========================
% Sistema Operativo: xv6
% =========================
\subsection{xv6}

\subsubsection{Nombre del proyecto o sistema operativo}
xv6 es un sistema operativo educativo desarrollado por el MIT como una reimplementación moderna de Unix Sixth Edition (V6). Se utiliza ampliamente en cursos universitarios avanzados de sistemas operativos \cite{xv6_mit_about, xv6_wiki}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio principal (RISC-V): \url{https://github.com/mit-pdos/xv6-riscv} \cite{xv6_riscv}.

Repositorio histórico x86: \url{https://github.com/mit-pdos/xv6-public}.

Documentación del curso MIT 6.1810/6.828: \url{https://pdos.csail.mit.edu/6.1810/2024/xv6.html} \cite{xv6_mit_about}.

\subsubsection{Objetivo del proyecto}
El objetivo de xv6 es educativo: explicar los conceptos esenciales de un sistema operativo mediante un kernel pequeño y legible \cite{xv6_book}.

\subsubsection{Lenguajes de implementación}
xv6 está escrito principalmente en C, con partes en ensamblador para inicialización de procesador, interrupciones y cambio de modo \cite{xv6_book}.

\subsubsection{Arquitectura del sistema}
Implementa un kernel monolítico inspirado en Unix. Actualmente se enfoca en arquitectura RISC-V, con versiones previas para x86 \cite{xv6_riscv}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Gestión de procesos:} \texttt{fork()}, \texttt{exec()}, \texttt{wait()} y planificación \textit{round-robin}.
    \item \textbf{Gestión de memoria:} memoria paginada con tablas de páginas multinivel.
    \item \textbf{Sistema de archivos:} sistema con i-nodos, directorios, enlaces y comandos básicos.
    \item \textbf{Shell:} shell simple con tuberías y redirecciones.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Compilador:} \texttt{riscv64-unknown-elf-gcc}.
    \item \textbf{Construcción:} \texttt{make} y \textit{binutils}.
    \item \textbf{Pruebas:} \textit{QEMU} y \textit{GDB}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{figures/xv6}
    \caption{Interfaz de la terminal del sistema operativo xv6 ejecutándose en el emulador \textit{QEMU}. Extraído de la documentación del curso MIT 6.1810/6.828}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de xv6 es medio. Su código es compacto y muy usado como base de laboratorio en universidades \cite{xv6_book, xv6_wiki}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico inspirado en Unix V6                               \\ \hline
        \textbf{Lenguajes}         & C y ensamblador                                                      \\
        \textbf{Arquitecturas}     & RISC-V (actual), x86 (histórica)                                     \\
        \textbf{Componentes clave} & Procesos, memoria, sistema de archivos, shell, interrupciones        \\
        \textbf{Herramientas}      & GCC RISC-V, Make, QEMU, GDB                                          \\
        \textbf{Uso educativo}     & Muy alto: referencia académica internacional                         \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de xv6.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación de xv6 y del curso MIT 6.1810/6.828 \cite{xv6_mit_about, xv6_book}.}
\end{table}

% =========================
% Sistema Operativo: HobbyOS
% =========================
\subsection{HobbyOS}

\subsubsection{Nombre del proyecto o sistema operativo}
HobbyOS es un sistema operativo experimental desarrollado como proyecto personal para explorar el diseño de kernels y la interacción directa con el hardware \cite{hobbyos_repo, hobbyos_topics}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio oficial: \url{https://github.com/ObadiahCrowe/HobbyOS} \cite{hobbyos_repo}.

Colección de proyectos afines: \url{https://github.com/topics/hobby-os} \cite{hobbyos_topics}.

\subsubsection{Objetivo del proyecto}
Su objetivo es experimental y educativo: servir como base sencilla para estudiar el proceso de construcción de un kernel desde sus primeras etapas.

\subsubsection{Lenguajes de implementación}
HobbyOS está escrito principalmente en C, con secciones en ensamblador x86\_64 para el \textit{bootloader}, interrupciones y configuración inicial \cite{hobbyos_repo}.

\subsubsection{Arquitectura del sistema}
El diseño corresponde a un kernel monolítico simple orientado a arquitectura x86\_64.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Bootloader:} código en ensamblador que prepara el entorno de 64 bits y carga el kernel.
    \item \textbf{Kernel mínimo:} inicialización del sistema, pila y ejecución de código C.
    \item \textbf{Memoria temprana:} rutinas simples para administrar memoria física.
    \item \textbf{Interrupciones:} tablas y manejadores iniciales.
    \item \textbf{Salida de texto:} escritura directa en memoria de vídeo en modo texto.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Compilador cruzado:} \texttt{x86\_64-elf-gcc}.
    \item \textbf{Ensamblador:} NASM.
    \item \textbf{Pruebas:} \textit{QEMU} y \texttt{make}.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\linewidth]{figures/HobbyOSbasiccmd.png}
    \caption{Sesión de consola de HobbyOS mostrando comandos básicos del kernel. Extraído del repositorio oficial del proyecto}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de HobbyOS es bajo-medio, ideal para quienes desean comprender los primeros pasos en el diseño de kernels \cite{hobbyos_topics}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico minimalista                             \\ \hline
        \textbf{Lenguajes}         & C y ensamblador x86\_64                                   \\
        \textbf{Arquitecturas}     & x86\_64                                                   \\
        \textbf{Componentes clave} & Bootloader, kernel básico, memoria inicial, interrupciones \\
        \textbf{Herramientas}      & GCC cruzado, NASM, QEMU, Make                             \\
        \textbf{Uso educativo}     & Alto: estudio de arranque y estructura básica             \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de HobbyOS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la descripción del proyecto HobbyOS en GitHub \cite{hobbyos_repo, hobbyos_topics}.}
\end{table}

% =========================
% Sistema Operativo: MikeOS
% =========================
\subsection{MikeOS}

\subsubsection{Nombre del proyecto o sistema operativo}
MikeOS es un sistema operativo didáctico de 16 bits, minimalista y de código abierto, creado para demostrar los fundamentos de un sistema operativo sencillo en modo real \cite{mikeos_about}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Sitio web oficial y descargas: \url{https://mikeos.sourceforge.net/} \cite{mikeos_about}.

Documentación y manuales: \url{https://mikeos.sourceforge.net/doc.html} \cite{mikeos_purpose}.

\subsubsection{Objetivo del proyecto}
Su objetivo es educativo: enseñar ensamblador x86 de 16 bits y la implementación de llamadas al sistema en un kernel simple \cite{mikeos_purpose}.

\subsubsection{Lenguajes de implementación}
MikeOS está implementado casi por completo en ensamblador x86 de 16 bits (NASM), e incluye un intérprete de BASIC \cite{mikeos_source, mikeos_architecture}.

\subsubsection{Arquitectura del sistema}
Presenta una arquitectura monolítica en modo real, donde kernel, shell y programas comparten un espacio de memoria de 64 KB \cite{mikeos_architecture}.

\subsubsection{Componentes implementados}
\begin{itemize}
    \item \textbf{Kernel:} inicialización, interrupciones y carga de programas.
    \item \textbf{Bootloader:} carga del núcleo desde disquete o imagen.
    \item \textbf{Llamadas al sistema:} más de 60 funciones de E/S.
    \item \textbf{Shell:} intérprete de línea de comandos.
    \item \textbf{Intérprete de BASIC:} ejecución de programas básicos.
\end{itemize}

\subsubsection{Herramientas utilizadas}
\begin{itemize}
    \item \textbf{Ensamblador:} NASM.
    \item \textbf{Pruebas:} QEMU o Bochs.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/mikeos_interface.png}
    \caption{Editor de texto de MikeOS mostrando un programa de demostración en BASIC. Extraído del sitio oficial del proyecto}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad es bajo a medio-bajo, y es uno de los sistemas más accesibles para introducirse en ensamblador y fundamentos de sistemas operativos \cite{mikeos_purpose}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico simple en modo real de 16 bits   \\ \hline
        \textbf{Lenguajes}         & Ensamblador x86 (NASM), BASIC                      \\
        \textbf{Arquitecturas}     & x86 (16 bits)                                      \\
        \textbf{Componentes clave} & Kernel, bootloader, llamadas al sistema, BASIC     \\
        \textbf{Herramientas}      & NASM, QEMU/Bochs                                   \\
        \textbf{Uso educativo}     & Muy alto: introducción a ensamblador y SO simples  \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de MikeOS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación oficial de MikeOS \cite{mikeos_about, mikeos_purpose, mikeos_architecture}.}
\end{table}

% =========================
% Sistema Operativo: BareMetal OS
% =========================
\subsection{BareMetal OS}

\subsubsection{Nombre del proyecto o sistema operativo}
BareMetal OS (BMOS) es un sistema operativo de código abierto diseñado para ejecutarse directamente sobre hardware \textit{bare metal} en sistemas x86-64. El proyecto se define como un sistema basado en \textit{exokernel}, orientado a exponer recursos de hardware a las aplicaciones y reducir la sobrecarga típica de sistemas operativos tradicionales \cite{bmos_purpose, bmos_source}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio del proyecto (código y guía de construcción): \url{https://github.com/ReturnInfinity/BareMetal-OS} \cite{bmos_purpose, bmos_architecture}.

\subsubsection{Objetivo del proyecto}
El objetivo de BareMetal OS es experimental y de nicho: ofrecer un entorno de muy bajo nivel para ejecutar aplicaciones con control cercano al hardware, priorizando flexibilidad y eficiencia bajo el enfoque \textit{exokernel} \cite{bmos_purpose}.

\subsubsection{Lenguajes de implementación}
El sistema está desarrollado principalmente en ensamblador x86-64. Además, el repositorio contempla la construcción de aplicaciones en C/C++ (por ejemplo, demos o utilidades), usando GCC como compilador de apoyo \cite{bmos_source, bmos_purpose}.

\subsubsection{Arquitectura del sistema}
BareMetal OS adopta un enfoque \textit{exokernel}: el núcleo mantiene un diseño minimalista y busca exponer recursos de hardware a las aplicaciones para permitir optimizaciones específicas por tarea. El proyecto está enfocado en plataformas x86-64 multinúcleo \cite{bmos_architecture, bmos_purpose}.

\subsubsection{Componentes implementados}
Según la estructura descrita en el repositorio, BareMetal OS se organiza en componentes principales \cite{bmos_purpose}:
\begin{itemize}
    \item \textit{Pure64}: cargador (loader) del sistema.
    \item \textit{BareMetal}: kernel del sistema.
    \item \textit{Monitor}: interfaz simple de línea de comandos.
    \item \textit{BMFS}: utilidad asociada al \textit{BareMetal File System}.
    \item \textit{BareMetal-Demo}: colección de programas de demostración.
\end{itemize}

\subsubsection{Herramientas utilizadas}
El repositorio incluye un flujo de trabajo automatizado con el script \texttt{baremetal.sh}, que permite preparar, compilar e iniciar el sistema en máquina virtual \cite{bmos_purpose}. En general se emplean:
\begin{itemize}
    \item NASM (ensamblador) para compilar el cargador, kernel y aplicaciones en ensamblador.
    \item QEMU para pruebas rápidas en virtualización.
    \item GCC para compilar aplicaciones en C/C++ (cuando aplique).
    \item Git para obtener el código fuente.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/bmos_interface.png}
    \caption{BareMetal OS ejecutándose en entorno virtual, mostrando su interfaz tipo consola. Extraído del repositorio del proyecto}
    \label{fig:bmos_interface}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de BareMetal OS es medio-alto, ya que su estudio requiere bases sólidas de arquitectura x86-64 y programación de bajo nivel. Es más adecuado para escenarios avanzados, donde se busca comprender la interacción directa con el hardware y el enfoque \textit{exokernel} \cite{bmos_wiki, bmos_purpose}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        Diseño & Sistema basado en \textit{exokernel} orientado a ejecución \textit{bare metal} \\ \hline
        Lenguajes & Ensamblador x86-64 (principal) y soporte para C/C++ en utilidades/demos \\
        Arquitecturas & x86-64 \\
        Componentes clave & \textit{Pure64}, \textit{BareMetal} (kernel), \textit{Monitor}, \textit{BMFS}, demos \\
        Herramientas & NASM, QEMU, GCC, Git (flujo con \texttt{baremetal.sh}) \\
        Uso educativo & Avanzado: programación de bajo nivel y estudio de enfoque \textit{exokernel} \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de BareMetal OS.}
    \vspace{1mm}
    \textit{Nota. Adaptado del repositorio y documentación del proyecto BareMetal OS \cite{bmos_purpose, bmos_architecture}.}
\end{table}

% =========================
% Sistema Operativo: PintOS
% =========================
\subsection{PintOS}

\subsubsection{Nombre del proyecto o sistema operativo}
PintOS es un \textit{framework} de sistema operativo minimalista orientado a la enseñanza, diseñado para la arquitectura x86 de 32 bits. Se emplea ampliamente en cursos universitarios porque proporciona un código base deliberadamente incompleto que permite a los estudiantes implementar y comprender, de forma guiada, los componentes centrales de un sistema operativo \cite{pintos_stanford, pintos_source}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Documentación académica base (Stanford): \url{https://web.stanford.edu/class/cs140/projects/pintos/pintos_1.html} \cite{pintos_stanford}.

Guía de desarrollo y material complementario: \url{https://github.com/SajedHassan/CSEx61-pintos} \cite{pintos_purpose}.

\subsubsection{Objetivo del proyecto}
El objetivo de PintOS es estrictamente educativo. Su finalidad es que el estudiante construya progresivamente un sistema operativo funcional a partir de un esqueleto inicial, implementando hilos, sincronización, soporte de programas de usuario, llamadas al sistema, memoria virtual y un sistema de archivos. En ese sentido, PintOS funciona como un laboratorio estructurado donde cada entrega añade capacidades reales al kernel y obliga a justificar decisiones de diseño \cite{pintos_purpose, pintos_stanford}.

\subsubsection{Lenguajes de implementación}
El núcleo y la mayor parte del código están implementados en C. Las rutinas de más bajo nivel, necesarias para el arranque, manejo de interrupciones y cambios de contexto, se implementan en ensamblador x86. Además, el entorno de construcción y automatización incluye scripts auxiliares, típicamente escritos en Perl \cite{pintos_source}.

\subsubsection{Arquitectura del sistema}
PintOS utiliza un diseño monolítico académico para x86 de 32 bits: las funciones principales (planificación, sincronización, manejo de memoria, llamadas al sistema y sistema de archivos) residen en el kernel. Sin embargo, su enfoque no es “dar un SO terminado”, sino ofrecer una arquitectura sencilla y controlada para que el alumno integre módulos por etapas, manteniendo un flujo de trabajo repetible de compilación, ejecución y prueba en emuladores \cite{pintos_stanford}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/pintos_qem.png}
    \caption{Componentes del Sistema Operativo PintOS. Extraído del repositorio del proyecto}
    \label{fig:pintos-qemu}
\end{figure}

\subsubsection{Componentes implementados}
PintOS se organiza típicamente en cuatro bloques de trabajo que estructuran el aprendizaje:

\begin{itemize}
    \item \textbf{Threads:} implementación y gestión de hilos, primitivas de sincronización (bloqueos, semáforos, condiciones) y políticas básicas de planificación.
    \item \textbf{User Programs:} carga de ejecutables, manejo de argumentos y construcción de la interfaz de llamadas al sistema entre espacio de usuario y kernel.
    \item \textbf{Virtual Memory:} soporte de paginación, tratamiento de fallos de página, y mecanismos que permiten que los procesos administren memoria de forma más realista.
    \item \textbf{File System:} construcción de un sistema de archivos funcional con soporte de directorios, persistencia en disco y operaciones típicas de lectura/escritura.
\end{itemize}

\subsubsection{Herramientas utilizadas}
El flujo de trabajo está pensado para entornos GNU/Linux, usando herramientas estándar:

\begin{itemize}
    \item \textbf{Compilación:} GCC y utilidades de binarios (\texttt{binutils}), con automatización mediante \texttt{make}.
    \item \textbf{Depuración:} GDB para inspección y depuración a nivel de kernel.
    \item \textbf{Pruebas y ejecución:} emulación en \textit{QEMU} o \textit{Bochs}, lo que permite iterar rápidamente sin hardware dedicado \cite{pintos_stanford}.
\end{itemize}


\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de PintOS es medio-alto. Aunque su diseño es intencionalmente simple en comparación con sistemas operativos de producción, el estudiante debe implementar conceptos críticos que suelen ser difíciles: sincronización correcta, interfaz de llamadas al sistema, paginación y persistencia en disco. Su accesibilidad es alta para fines académicos porque el proyecto está ampliamente documentado, estructurado en etapas y respaldado por materiales docentes \cite{pintos_stanford, pintos_purpose}.

\begin{table}[H]
    \centering
    \begin{tabular}{p{4cm}p{10cm}}
        \hline
        \textbf{Diseño}            & Kernel monolítico académico para x86 de 32 bits \\ \hline
        \textbf{Lenguajes}         & C, ensamblador x86, Perl (scripts) \\
        \textbf{Arquitecturas}     & x86 (32 bits) \\
        \textbf{Componentes clave} & Hilos, llamadas al sistema, memoria virtual, sistema de archivos \\
        \textbf{Herramientas}      & GCC, Make, Perl, QEMU/Bochs, GDB \\
        \textbf{Uso educativo}     & Muy alto: base estructurada para cursos universitarios \\
        \hline
    \end{tabular}
    \caption{Ficha técnica resumida de PintOS.}
    \vspace{1mm}
    \textit{Nota. Adaptado de la documentación académica de PintOS \cite{pintos_stanford, pintos_purpose}.}
\end{table}
