\section{Propuestas Analizadas}

% =========================
% Propuesta 1: HelenOS
% =========================
\subsection{HelenOS}

\subsubsection{Nombre del proyecto o sistema operativo}
HelenOS es un sistema operativo multiserver basado en un microkernel, desarrollado completamente desde cero y sin dependencia de Unix. Su diseño busca la modularidad, la portabilidad y la tolerancia a fallos, orientado principalmente a la investigación académica y la enseñanza de arquitectura de sistemas operativos \cite{helenos_about}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio oficial: \url{https://github.com/HelenOS/helenos}.

Sitio web del proyecto: \url{https://www.helenos.org}.

Documentación técnica (PDF): \url{https://www.helenos.org/doc/prjdoc.pdf}

\subsubsection{Objetivo del proyecto}
El objetivo de HelenOS es principalmente \textbf{educativo y experimental}. Su propósito es servir como plataforma de estudio de sistemas operativos modernos, promoviendo un enfoque modular donde cada servicio (sistema de archivos, red, controladores o interfaz gráfica) se implementa como un servidor independiente en espacio de usuario. Este diseño fomenta el análisis de conceptos avanzados como la comunicación entre procesos (IPC) y la separación entre el núcleo y los servicios de usuario \cite{helenos_about}.

\subsubsection{Lenguaje de implementación}
El proyecto está desarrollado principalmente en el lenguaje \textbf{C}, con partes críticas escritas en \textbf{ensamblador} (para el arranque del sistema y la gestión de interrupciones). Se mantiene compatibilidad con los estándares \textbf{C11} y \textbf{C++14}, facilitando la portabilidad y la integración de nuevos componentes \cite{helenos_prjdoc}.

\subsubsection{Arquitectura del sistema}
HelenOS adopta una arquitectura \textbf{microkernel multiserver}. El microkernel proporciona únicamente los servicios esenciales —planificación, gestión de memoria, interrupciones e IPC— mientras que todos los demás servicios (como el sistema de archivos, la red o la interfaz gráfica) se ejecutan como procesos de usuario independientes que se comunican mediante paso de mensajes (\emph{message passing}) \cite{helenos_prjdoc}.

\subsubsection{Componentes implementados}
\begin{itemize}
	\item \textbf{Gestión de procesos e hilos:} Soporta multitarea con planificación por prioridades y aislamiento entre procesos. El modelo de ejecución permite múltiples hilos por proceso y comunicación sincronizada entre ellos mediante IPC.

	\item \textbf{Gestión de memoria:} Implementa un sistema de memoria virtual con paginación y protección por espacio de direcciones. El kernel se encarga de la asignación básica y los servidores de usuario gestionan asignadores dinámicos (\textit{slab allocators}) y regiones compartidas.

	\item \textbf{Sistema de archivos (VFS):} Se basa en una arquitectura de VFS (Virtual File System) donde cada tipo de sistema de archivos (por ejemplo, FAT, EXT2) se implementa como un servidor separado en espacio de usuario. Esto permite montar y desmontar sistemas de archivos sin reiniciar el núcleo.

	\item \textbf{Dispositivos y controladores:} Los \textit{drivers} se ejecutan fuera del núcleo (user-space drivers), lo que evita que los errores en controladores afecten la estabilidad general del sistema. Hay soporte para dispositivos de almacenamiento, red, USB, video, teclado y mouse.

	\item \textbf{Sistema de red:} Incluye una pila TCP/IP modular con soporte para IPv4, interfaces Ethernet virtuales, y utilidades de diagnóstico como \texttt{ping}, \texttt{netstat}, \texttt{inet list-addr} y \texttt{arp}.

	\item \textbf{Sistema gráfico:} Dispone de un entorno gráfico de ventanas (GUI) que corre completamente en espacio de usuario. Proporciona aplicaciones nativas como \textit{Terminal}, \textit{Text Editor}, \textit{Navigator}, \textit{Calculator}, \textit{GFX Demo} y \textit{Tetris}. El gestor de ventanas se comunica con el servidor gráfico a través del protocolo \texttt{display-server}.

	\item \textbf{Comunicación e IPC:} El núcleo ofrece un sistema de comunicación entre procesos mediante intercambio de mensajes (\textit{message passing}) orientado a puertos. Este mecanismo es la base de toda interacción entre servidores y aplicaciones.

	\item \textbf{Seguridad y aislamiento:} Cada componente ejecuta con privilegios mínimos. Si un servidor falla, el kernel lo aísla y otros componentes pueden seguir ejecutándose, lo que mejora la tolerancia a fallos.

	\item \textbf{Portabilidad:} El código fuente está diseñado para ser independiente de la arquitectura. Actualmente soporta múltiples plataformas: \texttt{ia32}, \texttt{amd64}, \texttt{arm32}, \texttt{mips32}, \texttt{ppc32}, \texttt{sparc64} e incluso \texttt{ia64} (Itanium).
\end{itemize}

\subsubsection{Herramientas utilizadas}

El proceso de compilación y prueba de HelenOS requiere la preparación de un entorno de desarrollo cruzado (\emph{cross-compiling}) que permite generar imágenes del sistema para múltiples arquitecturas. A continuación se detallan las principales herramientas utilizadas:

\begin{itemize}
	\item \textbf{Toolchain cruzado:} Se genera mediante el script \texttt{tools/toolchain.sh}, que compila una cadena completa de herramientas \texttt{gcc}, \texttt{binutils} y \texttt{gdb} adaptadas para la arquitectura destino (por ejemplo, \texttt{ia64-helenos-gcc}). El entorno de compilación se instala por defecto en el directorio \texttt{/usr/local/cross} y puede personalizarse mediante la variable \texttt{CROSS\_PREFIX}.

	\item \textbf{Meson y Ninja:} HelenOS utiliza el sistema de construcción \textbf{Meson} junto al generador \textbf{Ninja}, lo que permite una configuración modular y compilaciones rápidas e incrementales.

	\item \textbf{Dependencias del entorno:} Para distribuciones basadas en Debian/Ubuntu, se necesitan los paquetes \texttt{build-essential}, \texttt{wget}, \texttt{texinfo}, \texttt{flex}, \texttt{bison}, \texttt{dialog}, \texttt{python3-yaml} y \texttt{genisoimage}.

	\item \textbf{Configuración del proyecto:} El script \texttt{configure.sh} permite definir perfiles preestablecidos de compilación. Por ejemplo, para la arquitectura \texttt{amd64}:
	      \begin{verbatim}
  git clone https://github.com/HelenOS/helenos.git
  mkdir -p build/amd64
  cd build/amd64
  ../../helenos/configure.sh amd64
  ninja
  ninja image_path
  \end{verbatim}

	\item \textbf{Emulación y prueba:} HelenOS puede ejecutarse en \textbf{QEMU} o \textbf{VirtualBox}. Para iniciar el sistema en QEMU se recomienda:
	      \begin{verbatim}
  qemu-system-x86_64 -m 512 -cdrom image.iso \
  -usb -device usb-tablet -serial mon:stdio -display sdl
  \end{verbatim}
\end{itemize}

Además, el repositorio incluye scripts auxiliares en \texttt{tools/ew.py} que automatizan el proceso de arranque en QEMU, y configuraciones predefinidas en \texttt{tools/conf} para ajustar parámetros de memoria o dispositivos virtuales.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{figures/helenos_toolchain.png}
	\caption{Elaboración Propia. Compilación cruzada del toolchain.sh}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de HelenOS es alto, ya que su comprensión requiere conocimientos de compilación cruzada, IPC y gestión de memoria. Sin embargo, su estructura modular y bien documentada lo convierte en una excelente herramienta didáctica donde se pueden analizar de manera aislada servicios específicos como el sistema de archivos o el entorno gráfico \cite{helenos_docs}.

\begin{table}[H]
	\centering
	\caption{Ficha técnica resumida de HelenOS.}
	\vspace{1em}
	\begin{tabular}{p{4cm}p{10cm}}
		\hline
		\textbf{Diseño}            & Microkernel multiserver modular                                     \\ \hline
		\textbf{Lenguajes}         & C (principal) y ensamblador (arranque y bajo nivel)                 \\
		\textbf{Arquitecturas}     & ia32, amd64, arm32, mips32, ppc32, sparc64                          \\
		\textbf{Componentes clave} & Kernel mínimo, VFS, red, GUI, drivers en espacio de usuario         \\
		\textbf{Herramientas}      & GCC (toolchain cruzado), Meson, Ninja, QEMU/VirtualBox              \\
		\textbf{Uso educativo}     & Alto: análisis modular de componentes y comunicación entre procesos \\
		\hline
	\end{tabular}\\
	\vspace{1mm}
	\textit{Nota.} Adaptado de “About HelenOS” (HelenOS Project, 2024)
\end{table}

% =========================
% Propuesta 2: Visopsys
% =========================
\subsection{Visopsys}

\subsubsection{Nombre del proyecto o sistema operativo}
Visopsys (\textit{Visual Operating System}) es un sistema operativo alternativo, gratuito y desarrollado desde cero por Andy McLaughlin desde 1997. A diferencia de otros sistemas, no está basado en Unix ni Linux, sino que implementa su propio kernel, gestor de archivos y entorno gráfico. Está diseñado para ser compacto, rápido y con una interfaz visual moderna, integrando tanto funcionalidades de línea de comandos como de entorno gráfico \cite{visopsys_about, visopsys_scribd}.

\subsubsection{Enlace al repositorio y/o documentación oficial}
Repositorio oficial y descargas: \url{https://sourceforge.net/projects/visopsys/files/}

Sitio web del proyecto: \url{https://visopsys.org}

Presentación técnica (Scribd): \url{https://es.scribd.com/presentation/619552414/SO-visopsys}

\subsubsection{Objetivo del proyecto }
El objetivo de Visopsys es \textbf{educativo y experimental}. Busca proporcionar una plataforma funcional que demuestre los principios fundamentales del diseño de sistemas operativos, la gestión de procesos, la memoria y los sistemas de archivos. Está enfocado en ser simple, visual y completamente entendible, lo que lo hace ideal para el estudio de arquitecturas operativas en cursos de ingeniería de sistemas o informática \cite{visopsys_scribd}.

\subsubsection{Lenguajes de implementación}
El sistema está implementado principalmente en el lenguaje \textbf{C}, con secciones críticas escritas en \textbf{ensamblador x86}. Esta combinación le permite optimizar la comunicación con el hardware y mantener un tamaño reducido del núcleo y del sistema base \cite{visopsys_sourceforge}.

\subsubsection{Arquitectura del sistema}
Visopsys implementa una arquitectura \textbf{monolítica modular}. Su núcleo controla directamente los procesos, la gestión de memoria, el sistema de archivos y los controladores de dispositivos, aunque permite la carga dinámica de módulos y extensiones en tiempo de ejecución. Esto le otorga un balance entre rendimiento, simplicidad y capacidad de expansión \cite{visopsys_about}.

\subsubsection{Componentes implementados}
\begin{itemize}
	\item \textbf{Gestión de procesos e hilos:} Visopsys soporta multitarea cooperativa y por prioridades, con un planificador de procesos básico implementado en su núcleo. Cada tarea dispone de su propio contexto de ejecución y control de interrupciones.

	\item \textbf{Gestión de memoria:} Implementa un sistema de memoria virtual simple con asignación dinámica y control directo del espacio de direcciones. El sistema garantiza aislamiento básico entre tareas activas.

	\item \textbf{Sistema de archivos:} Integra su propio sistema VFS con soporte para FAT12, FAT16 y FAT32, además de detección de tablas de particiones MBR y GPT. Incluye herramientas gráficas para formateo, copia, borrado y verificación de discos.

	\item \textbf{Dispositivos y controladores:} Dispone de controladores nativos para discos IDE y SATA, tarjetas gráficas básicas (modo VESA), teclado, mouse y almacenamiento USB. Los drivers se integran directamente en el kernel.

	\item \textbf{Interfaz gráfica (GUI):} Ofrece un entorno gráfico funcional con ventanas, menús y una barra de herramientas principal. Incluye aplicaciones integradas como un administrador de archivos, visor hexadecimal, editor de texto y panel de control del sistema.

	\item \textbf{Herramientas del sistema:} Contiene utilidades para crear, copiar o gestionar particiones, visualizar la memoria y monitorear el rendimiento del CPU en tiempo real.

	\item \textbf{Soporte de hardware:} El sistema está diseñado para funcionar en procesadores x86 y x86-64, aunque se ejecuta principalmente en entornos de 32 bits para mantener compatibilidad amplia.
\end{itemize}

\subsubsection{Herramientas utilizadas}
Visopsys puede compilarse con \textbf{GCC} en sistemas Linux, BSD o Windows mediante entornos cruzados. También se distribuye como una \textbf{ISO ejecutable} que puede probarse directamente sin instalación.

\begin{itemize}
	\item \textbf{Compilador:} GCC y utilidades estándar de GNU (\texttt{make}, \texttt{binutils}).
	\item \textbf{Entorno de prueba:} Compatible con \textbf{VirtualBox} y \textbf{QEMU}.
	\item \textbf{Configuración sugerida:}
	      \begin{verbatim}
Sistema: Other/Unknown (32-bit)
Memoria: 256 MB
Arranque: visopsys-0.92.iso
Desactivar EFI y habilitar CD-ROM
  \end{verbatim}
	\item \textbf{Ejecución:} Al iniciar desde la ISO, carga automáticamente el entorno gráfico sin requerir instalación.
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\linewidth]{figures/visopsys_gui.png}
	\caption{Implementación de Visopsys en VirtualBox.}
\end{figure}

\subsubsection{Nivel de complejidad y accesibilidad}
El nivel de complejidad de Visopsys es \textbf{medio}, ya que su código fuente es legible y su estructura modular facilita el aprendizaje. Permite explorar los conceptos fundamentales de sistemas operativos, como la planificación, memoria, drivers y GUI, dentro de un único entorno funcional y visual \cite{visopsys_scribd}.

\begin{table}[H]
	\centering
	\caption{Ficha técnica resumida de Visopsys.}
	\vspace{1em}
	\begin{tabular}{p{4cm}p{10cm}}
		\hline
		\textbf{Diseño}            & Monolítico modular con GUI integrada                                                \\ \hline
		\textbf{Lenguajes}         & C y ensamblador (x86)                                                               \\
		\textbf{Arquitecturas}     & x86 (32 bits)                                                                       \\
		\textbf{Componentes clave} & Kernel, VFS, GUI, gestor de procesos, controladores IDE/SATA, herramientas gráficas \\
		\textbf{Herramientas}      & GCC, Make, VirtualBox/QEMU                                                          \\
		\textbf{Uso educativo}     & Medio: análisis de kernel, GUI y gestión de memoria                                 \\
		\hline
	\end{tabular}\\
	\vspace{1mm}
	\textit{Nota.} Adaptado de “SO Visopsys” (McLaughlin, 2023).
\end{table}
% =======================================
% Investigación de Toarus y otro SO extra - Rosy
% =======================================

\subsection{ToarusOS}
\subsubsection{Nombre del proyecto o sistema operativo}
ToaruOS es un sistema operativo independiente, escrito casi completamente desde cero, diseñado como un recurso educativo que ofrece una implementación completa de un SO moderno.


\subsubsection{Enlace al repositorio y/o documentación oficial}

Repositorio oficial: \url{https://github.com/klange/toaruos}

Sitio web del proyecto: \url{http://toaruos.org/}

\subsection{Objetivo del proyecto}
ToarusOS esta diseñado para servir como recurso educativo que permita estudiar y comprender el funcionamiento de un sistema operativo completo. Pretendiendo ser una representación compacta y funcional de los componentes que forman parte de un sistema operativo de escritorio moderno.

\subsubsection{Lenguajes de implementación}
ToaruOS está implementado principalmente en el lenguaje de programación \textbf{C}, además de ello, se encuentra implementado con el lenguaje de programación de Kuroko, un lenguaje propio, un lenguaje de programación dinámico, compilado a bytecode y un dialecto de Python.

\subsubsection{Arquitectura del sistema}
ToaruOS adopta una arquitectura que posee un kernel híbrido y modular, denominada Misaka, es una arquitectura híbrida con módulos cargables en tiempo de ejecución. El kernel proporciona servicios esenciales como la gestión de procesos, memoria y sistemas de archivos, mientras que otros componentes del sistema operativo, como el entorno gráfico y las aplicaciones, se ejecutan en espacio de usuario.

\subsubsection{Componentes implementados}
\begin{itemize}
	\item \textbf{Gestión de procesos e hilos:} ToaruOS ToaruOS utiliza el kernel Misaka, un núcleo híbrido con soporte para multiprocesamiento simétrico (SMP), que implementa un planificador de procesos, mecanismos de comunicación entre procesos mediante el sistema pex y una arquitectura basada en procesos expuestos a través del sistema de archivos virtual \texttt{/proc}.
	\item \textbf{Gestión de memoria: } Incorpora un sistema de memoria  con paginación y asignación dinámica dentro del kernel, complementado por una implementación propia de la biblioteca estándar de C (libc) que administra la memoria en espacio de usuario, junto con el uso de un ramdisk comprimido como sistema de archivos raíz inicial.
	\item \textbf{Sistema de archivos:} ToaruOS emplea un filesystem raíz montado desde un ramdisk e incluye soporte para ISO9660, además de una estructura tipo Unix que integra directorios virtuales como /dev, /proc y /tmp, permitiendo la interacción con dispositivos, procesos y almacenamiento temporal de forma eficiente.
	\item \textbf{Dispositivos y controladores:} El sistema dispone de un conjunto modular de controladores cargables que gestionan dispositivos gráficos, audio, almacenamiento IDE, red y periféricos de entrada, ofreciendo además integración avanzada con entornos de virtualización como VirtualBox y VMware, mientras continúa el desarrollo de drivers adicionales como AHCI, USB y virtio.
	\item \textbf{Interfaz gráfica (GUI):}  ToaruOS cuenta con un entorno gráfico completo basado en Yutani, un servidor de ventanas compositado con aceleración por software y un diseño inspirado en interfaces de finales de los años 2000, acompañado por un conjunto de aplicaciones y herramientas gráficas como la Terminal, el editor Bim y el sistema de widgets TTK.
	\item \textbf{Herramientas de sistema:} Incluye utilidades fundamentales como el shell Esh con soporte para tuberías y redirecciones, el cargador dinámico ld.so, el editor de texto Bim, el lenguaje de programación Kuroko y un conjunto de comandos Unix-like, complementados por herramientas de desarrollo internas como auto-dep.krk.
	\item \textbf{Soporte de hardware:} ToaruOS funciona principalmente sobre arquitecturas x86-64, con soporte experimental para ARMv8 y compatibilidad comprobada tanto en entornos virtualizados como en hardware real, incorporando funcionalidades específicas para mejorar la experiencia en máquinas virtuales y extendiendo continuamente su compatibilidad mediante el desarrollo de nuevos controladores.
\end{itemize}