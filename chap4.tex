\chapter{Análisis crítico}

Al comparar las distintas propuestas, se observa una diferencia clara entre los sistemas diseñados solo para enseñar lo básico (como xv6 o PintOS) y aquellos que buscan ser sistemas completos (como SerenityOS). La mayoría de estos proyectos utiliza una arquitectura monolítica, donde todo el sistema corre en un solo bloque, ya que es más fácil de entender al principio. Sin embargo, la elección de HelenOS destaca por ser diferente: al usar un diseño de microkernel, separa las funciones en partes independientes. Esto es muy valioso para el aprendizaje, ya que permite estudiar cómo dividir un sistema complejo en módulos y cómo aislar errores, algo que los sistemas más simples no suelen mostrar.

En cuanto a los problemas técnicos, el obstáculo más común en casi todos los proyectos es la configuración inicial de las herramientas de compilación (toolchain). Además, el manejo de la memoria y la ejecución de varios procesos a la vez suelen ser las partes más difíciles de programar. En el caso específico de HelenOS, se suma un reto adicional: la comunicación entre procesos (IPC). A diferencia de los sistemas monolíticos donde el núcleo hace todo directamente, en HelenOS los componentes deben enviarse mensajes para funcionar. Esto obliga a entender bien cómo coordinar distintas tareas sin que el sistema se vuelva lento o se bloquee.

Finalmente, para el desarrollo del proyecto con HelenOS, es útil tomar ideas de los otros sistemas analizados. De xv6 se puede imitar la claridad del código, y de proyectos como Visopsys, la importancia de mantener una estructura ordenada. El objetivo principal al trabajar con HelenOS no debe ser solo hacer que el sistema arranque, sino aprovechar su diseño modular. Lo interesante es demostrar que, al ejecutar los controladores (drivers) y sistemas de archivos como programas separados, se logra un sistema más estable: si una parte falla, el resto del sistema operativo puede seguir funcionando, una ventaja clara frente a los modelos tradicionales.